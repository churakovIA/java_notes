# Рефлексия
С помощью рефлексии можно исследовать содержимое произвольных объектов во время выполнения прикладной программы и вызывать для них произвольные методы. 
Такая возможность удобна для реализации инструментальных средств вроде объектно-реаляционных преобразователей или построителей ГПИ.

## Динамические прокси классы
Предназначены для того, чтобы создавать во время выполнения программы новые классы, реализующие заданные интерфейсы. 
Прокси-класс может создавать во время выполнения совершенно новые классы и реализует те интерфейсы, которые указывает программист. 
В частности, в прокси-классе содержатся следующие методы: 

 - Все методы, которые требуют указанные интерфейсы. 
 - Все методы, определенные в классе Object (в том числе toString (), equals () 
и т.д.). 

Но определить новый код для этих методов в ходе выполнения программы нельзя. 
Вместо этого программист должен предоставить обработчик вызовов, т.е. объект любого класса, реализующего интерфейс [InvocationHandler][1]. 
В этом интерфейсе единственный метод объявляется следующим образом: 
```java
Object	invoke(Object proxy, Method method, Object[] args)
//Этот метод определяется с целью задать действие, которое должно быть выполнено при вызове какого-нибудь метода для прокси-объекта. 
```
При вызове какого-нибудь метода для прокси-объекта автоматически вызывается метод invoke () из обработчика вызовов, 
получающий объект класса Method и параметры исходного вызова. 

```java
class CustomInvocationHandler implements InvocationHandler
{
    private Reader readerOriginal;

    CustomInvocationHandler(Reader readerOriginal)
    {
        this.readerOriginal = readerOriginal;
    }

    public Object invoke(Object proxy, Method method, Object[] args) throws Throwable
    {
        if (method.getName().equals("close"))
        {
            System.out.println("Reader closed!");
        }

        // это вызов метода close у объекта readerOriginal
        // имя метода и описание его параметров хранится в переменной method
        return method.invoke(readerOriginal, args);
    }
}
```

**Создание прокси-объектов**

Для создания прокси-объекта служит метод `newProxyInstance()` из класса [Proxy][2].
```java
static Object	newProxyInstance(ClassLoader loader, Class<?>[] interfaces, InvocationHandler h)
```

Этот метод получает следующие три параметра: 
 - **Загрузчик классов**. Модель безопасности в Java позволяет использовать загрузчики разных классов, 
 в том числе системных классов, загружаемых из Интернета, и т.д. Можно передавать null, чтобы использовать загрузчик классов, предусмотренный по умолчанию. 
 - **Массив объектов типа Class** — по одному на каждый реализуемый интерфейс. 
 - **Обработчик вызовов** 

**Прокси-объекты могут использоваться для следующих целей:**
 - Переадресация вызовов методов на удаленный сервер. 
 - Связывание событий, происходящих в пользовательском интерфейсе, с определенными действиями, выполняемыми в программе. 
 - Отслеживание вызовов методов при отладке. 
 - Проверка прав доступа
 
 > **Пример конструирования прокси-объекта:**
 ```java
 Reader original = new UserCustomReader();

ClassLoader classLoader = original.getClass().getClassLoader();
Class<?>[] interfaces = original.getClass().getInterfaces();
CustomInvocationHandler invocationHandler = new CustomInvocationHandler(original);

Reader reader = (Reader)Proxy.newProxyInstance(classLoader, interfaces, invocationHandler);
 ```

Все прокси-классы расширяют класс Proxy. Такой класс содержит только одну 
переменную экземпляра, которая ссылается на обработчик вызовов, определенный 
в суперклассе Proxy. Любые дополнительные данные, необходимые для выполнения 
задач, решаемых прокси-объектами, должны храниться в обработчике вызовов. 

Во всех прокси-классах переопределяются методы `toString()`, `equals()` 
и `hashCode()` из класса _Object_. Эти методы лишь вызывают метод `invoke()` для обработчика вызовов. 
Другие методы из класса _Object_ (например, `clone()` и `getClass()`) не переопределяются. Имена прокси-классов не определены. 
В виртуальной машине формируются имена классов, начинающиеся со строки _$Proxy_. 
Для конкретного загрузчика классов и заданного набора интерфейсов может существовать только один прокси-класс. 
Это означает, что, если дважды вызвать метод `newProxylnstance()` для одного и того же загрузчика классов и массива интерфейсов, 
будут получены два объекта одного и того же класса. Имя этого класса можно определить с помощью метода `getProxyClass()` следующим образом: 
```java
Class proxyClass = Proxy.getProxyClass(null, interfaces); 
```

> **Дополнительный материал:**\
> https://restless-man.livejournal.com/24320.html \
> https://www.ibm.com/developerworks/ru/library/j-jtp08305/index.html \
> https://javarush.ru/quests/lectures/questcollections.level02.lecture07] \
> Java Библиотека профессионала том 1, издание 10, 2016, (Хорстманн,Корнел) _Глава 6.5 Прокси классы._ 

[1]: https://docs.oracle.com/javase/8/docs/api/java/lang/reflect/InvocationHandler.html
[2]: https://docs.oracle.com/javase/8/docs/api/java/lang/reflect/Proxy.html
