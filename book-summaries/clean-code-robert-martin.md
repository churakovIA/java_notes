# Чистый код - создание, анализ и рефакторинг (Роберт Мартин)

## Глава 1. Чистый код

**Да будет код**

Код никогда не исчезнет, потому что код представляет подробности требований. На определенном уровне эти подробности невозможно игнорировать или абстрагировать; их приходится определять. А когда требования определяются настолько подробно, чтобы они могли быть выполнены компьютером, это и есть программирование. А их определение есть код. 

...код представляет собой язык, на котором в конечном итоге выражаются потребности. 

*Плохой код*

Плохой код когда-нибудь мешал вашей работе? Любой сколько-нибудь опытный программист неоднократно попадал в подобную ситуацию. Мы продираемся через плохой код. Мы вязнем в хитросплетении ветвей, попадаем в скрытые ловушки. Мы с трудом прокладываем путь, надеясь получить хоть какую-нибудь подсказку, что же происходит в коде; но не видим вокруг себя ничего, кроме  новых залежей невразумительного кода. 

Каждый обещал себе вернуться и почистить код... потом. Конечно, в те дни мы еще не знали закон Леблана: потом равносильно никогда. 

**Расплата за хаос**

По мере накопления хаоса в коде производительность группы начинает  снижаться, асимптотически приближаясь к нулю. 

*Грандиозная переработка*

В конечном итоге группа устраивает бунт. Она сообщает начальству, что не может 
продолжать разработку отвратительной кодовой базы, и требует переработки 
архитектуры. 

Набирается новая «ударная группа». ... Всем остальным приходится сопровождать текущую систему. ... 

Между двумя группами начинается гонка. «Ударная группа» должна построить новую систему, которая делает то же самое, что делала старая. 

Такая гонка может продолжаться очень долго. ... И к моменту ее завершения оказывалось, что исходный состав давно покинул «ударную группу», а текущие участники требовали переработать новую систему, потому что в ней творился сущий хаос. 

*Отношение*

Почему хороший код так быстро загнивает и превращается в плохой код? У нас обычно находится масса объяснений. ... Однако вина лежит вовсе не на них, а на нас самих. Дело в нашем непрофессионализме. ...

Мы принимаем самое деятельное участие в планировании проекта и несем значительную долю ответственности за любые провалы; особенно если эти провалы обусловлены плохим кодом! 

... Начальники хотят видеть хороший код, даже если они помешаны на рабочем графике. Они могут страстно защищать график и требования; но это их работа. А ваша работа — так же страстно защищать код. 

Чтобы стало понятнее, представьте, что вы — врач, а ваш пациент требует прекратить дурацкое мытье рук при подготовке к операции, потому что это занимает 
слишком много времени! 

Таким образом, программист, который подчиняется воле начальника, не понимающего опасность некачественного кода, проявляет непрофессионализм. 

*Основной парадокс*

... Каждый разработчик, имеющий сколько-нибудь значительный опыт работы, знает, 
что предыдущий беспорядок замедляет его работу. Но при этом все разработчики под давлением творят беспорядок в своем коде для соблюдения графика. ...

Единственный способ выдержать график — и единственный способ работать быстро —  заключается в том, чтобы постоянно поддерживать чистоту в коде. 

*Искусство чистого кода?*

Бесполезно пытаться написать чистый код, если вы не знаете, что это такое! ...

... умение отличать чистый код от  грязного еще не означает, что вы умеете писать чистый код! ...

Программист без «чувства кода» посмотрит на грязный модуль и распознает 
беспорядок, но понятия не имеет, что с ним делать. Программист с «чувством 
кода» смотрит на грязный модуль и видит различные варианты и возможности. 

**Что такое «чистый код»?**

... чистый код приятно читать. Плохой код искушает, способствуя увеличению беспорядка! Когда другие программисты изменяют плохой код, они обычно делают его еще хуже. ... Суть в том, что чистый код уделяет пристальное внимание мелочам. 

... чистый код хорошо решает одну задачу. Не случайно многие принципы проектирования программного обеспечения сводятся к этому простому наставлению. ... Плохой код пытается сделать слишком много всего, для него характерны неясные намерения и неоднозначность целей. Для чистого кода  характерна целенаправленность. Каждая функция, каждый класс, каждый модуль фокусируются на конкретной цели, не отвлекаются от нее и не загрязняются окружающими подробностями. 

...

... чистый код должен читаться, как хорошо написанная проза. 

... Наш код должен быть фактическим, а не умозрительным. Он должен содержать только то, что необходимо. Читатель должен видеть за кодом нашу решительность.  

...

... чистота кода упрощает его доработку другими людьми. 

... код, который легко читается, и код, который легко изменяется, — не одно и то же. 

... Код без тестов не может быть назван чистым, каким бы элегантным он ни был и как бы хорошо он ни читался. 

...

... Чистый код — это код, над которым тщательно поработали. Кто-то не пожалел своего времени, чтобы сделать его простым и стройным. Кто-то уделил должное внимание всем мелочам и относился к коду с душой. 

...

В порядке важности, простой код: 
— проходит все тесты; 
— не содержит дубликатов; 
— выражает все концепции проектирования, заложенные в систему; 
— содержит минимальное количество сущностей: классов, методов, функций 
и т. д. 

... Выразительность для меня прежде всего означает содержательность имен. 

... Я также смотрю, не выполняет ли объект или метод более одной операции. Если 
это объект, то его, вероятно, стоит разбить на два и более объекта. ...

... Отсутствие дублирования и выразительности являются важнейшими составляющими чистого кода в моем понимании. Даже если при улучшении грязного кода вы будете руководствоваться только этими двумя целями, разница в качестве 
кода может быть огромной. 

... Сокращение дублирования, высокая  выразительность и раннее построение простых абстракций. Все это составляет чистый код 

...

... чтение чистого кода вас совершенно не удивит. В самом деле, оно даже не потребует от вас особых усилий. Вы читаете код, и он делает примерно то, что вы ожидали. Чистый код очевиден, прост и привлекателен. Каждый модуль создает условия для следующего. Каждый модуль показывает, как будет написан следующий модуль. Чистые программы написаны настолько хорошо, что вы этого даже не замечаете. 

... Не язык делает программы простыми. Программа выглядит простой благодаря работе программиста! 

**Школы мысли**

В самом деле, многие рекомендации в этой книге противоречивы. Вероятно, вы 
согласитесь не со всеми из них. Возможно, против некоторых вы будете яростно 
протестовать. Это нормально. Мы не претендуем на абсолютную истину. С другой стороны, приведенные в книге рекомендации являются плодами долгих, 
непростых размышлений. Мы пришли к ним после десятилетий практической 
работы, непрестанных проб и ошибок. Независимо от того, согласитесь вы с нами 
или нет, нашу точку зрения стоит по крайней мере узнать и уважать. 

**Мы — авторы**

... Когда вы в следующий раз напишете строку кода, вспомните, что вы — автор, и пишете для читателей, которые будут оценивать плоды вашей работы. 

... соотношение времени чтения и написания кода превышает 10:1. Мы постоянно читаем свой старый код, поскольку это необходимо для написания нового кода. 

Из-за столь высокого соотношения наш код должен легко читаться, даже если 
это затрудняет его написание. Конечно, написать код, не прочитав его, невозможно, так что упрощение чтения в действительности упрощает и написание кода. 

Уйти от этой логики невозможно. Невозможно написать код без  предварительного чтения окружающего кода. Код, который вы собираетесь написать сегодня, будет легко или тяжело читаться в зависимости от того, насколько легко или тяжело читается окружающий код. Если вы хотите быстро справиться со своей задачей, если вы хотите, чтобы ваш код было легко писать — позаботьтесь о том, чтобы он легко читался. 

**Правило бойскаута**

Хорошо написать код недостаточно. Необходимо поддерживать чистоту кода 
с течением времени. ...

*Оставь место стоянки чище, чем оно было до твоего прихода*

Если мы все будем оставлять свой код чище, чем он был до нашего прихода, то 
код попросту не будет загнивать.  Чистка не обязана быть глобальной.

Представляете себе работу над проектом, код которого улучшается с течением времени? Но может ли профессионал позволить себе нечто иное? Разве постоянное совершенствование не является неотъемлемой частью профессионализма? 

## Глава 2. Содержательные имена

Мы присваиваем имена своим переменным, функциям, аргументам, классам и пакетам. Мы присваиваем имена исходным файлам и каталогам, в которых они хранятся. Мы присваиваем имена файлам jar, war wear. Имена, имена, имена... Но то, что делается так часто, должно делаться хорошо. 

**Имена должны передавать намерения программиста**

... следите за именами в своих  программах и изменяйте их, если найдете более удачные варианты. Этим вы  упростите жизнь каждому, кто читает ваш код (в том числе и себе самому). 
Имя переменной, функции или класса должно отвечать на все главные вопросы. 
Оно должно сообщить, почему эта переменная (и т. д.) существует, что она делает 
и как используется. Если имя требует дополнительных комментариев, значит, оно не передает намерений программиста. 

**Избегайте дезинформации**

Не используйте слова со скрытыми значениями, отличными от предполагаемого. 
Например, переменным не стоит присваивать имена hp, aix, and sco, потому что 
они ассоциируются с платформами и разновидностями Unix. 

Не обозначайте группу учетных записей именем accountLi st, если только она действительно не хранится в списке (Li st). Слово «список» имеет для программиста 
вполне конкретный смысл. Если записи хранятся не в List, а в другом контейнере, это может привести к ложным выводам. В этом примере лучше подойдет имя accountGroup, bunchOf Accounts и даже просто accounts. 

Остерегайтесь малозаметных различий в именах. 

Сходное представление сходных концепций — информация.  Непоследовательное представление — дезинформация. 

**Используйте осмысленные различия**

Недостаточно добавить в имя серию цифр или неинформативные слова, даже если компилятору этого будет достаточно. Если имена различаются, то они должны обозначать разные понятия. 

Неинформативные слова также применяются для создания бессодержательных 
различий. Допустим, у вас имеется класс Product. Создав другой класс с именем 
ProductInfo или ProductData, вы создаете разные имена, которые по сути  
обозначают одно и то же. 

Неинформативные слова избыточны. Слово variable никогда не должно  встречаться в именах переменных. Слово table никогда не должно встречаться в  именах таблиц. Чем имя NameString лучше Name? Разве имя может быть, скажем, вещественным числом? Если может, то это нарушает предыдущее правило о дезинформации. 

При отсутствии жестких именных схем имя moneyAmount не отличается от money, 
customerlnfo не отличается от customer, accountData не отличается от account, 
a theMessage — от message. Записывайте различающиеся имена так, чтобы читатель кода понимал, какой смысл заложен в этих различиях.

**Используйте удобопроизносимые имена**

Людям удобно работать со словами. Значительная часть нашего мозга специализируется на концепции слов, а слова по определению удобопроизносимы. 
Было бы обидно не использовать ту изрядную часть мозга, которая развивалась 
для разговорной речи. Следовательно, имена должны нормально произноситься. 

Если имя невозможно нормально произнести, то при любом его упоминании в обсуждении вы выглядите полным идиотом. А это важно, потому что программирование является социальной деятельностью.

**Выбирайте имена, удобные для поиска**

У однобуквенных имен и числовых констант имеется один специфический недостаток: их трудно искать в большом объеме текста. 

Еще хуже, если константа представляет собой длинное число, в котором были случайно переставлены цифры; в программе появляется ошибка, которая одновременно скрывается от поиска.

... длинные имена лучше коротких, а имена, удобные для поиска,  лучше констант в коде. 

*Длина имени должна соответствовать размеру его области видимости [N5].*

Если переменная или константа может встречаться или использоваться в нескольких местах кодового блока, очень важно присвоить ей имя, удобное для поиска.

**Избегайте схем кодирования имен**

Кодирование информации о типе или области видимости в именах только создает новые хлопоты по расшифровке. Вряд ли разумно заставлять каждого нового работника изучать очередной «язык» кодирования.

Как правило, кодированные имена плохо произносятся и в них легко сделать опечатку. 

*Венгерская запись*

... в наши дни венгерская запись и другие формы кодирования типов в именах превратились в обычные пережитки прошлого. Они усложняют изменение имени или типа переменных, функций и классов. Они затрудняют чтение кода. Наконец, они повышают риск того, что система кодирования собьет с толку читателя кода.

*Префиксы членов классов*

Префиксы m_, которыми когда-то снабжались переменные классов, тоже стали 
ненужными. Классы и функции должны быть достаточно компактными, чтобы 
вы могли обходиться без префиксов. 

Кроме того, люди быстро учатся игнорировать префиксы (и суффиксы), чтобы 
видеть содержательную часть имени. Чем больше мы читаем код, тем реже замечаем префиксы. В конечном итоге префикс превращается в невидимый балласт, характерный для старого кода. 

*Интерфейсы и реализации*

Я предпочитаю оставлять имена интерфейсов без префиксов. Префикс I, столь распространенный в старом коде, в лучшем случае отвлекает, а в худшем — передает лишнюю информацию. 

Имя ShapeFactorylmp, или даже уродливое CShapeFactory, все равно лучше кодирования информации об интерфейсе. 

**Избегайте мысленных преобразований**

Не заставляйте читателя мысленно преобразовывать ваши имена в другие, уже 
известные ему. Обычно эта проблема возникает из-за нежелания использовать 
понятия как из пространства задачи, так и из пространства решения. 

Нет худшей причины для выбора имени с, чем та, что имена а и b уже заняты. 

Одно из различий между умным и профессиональным программистом заключается в том, что профессионал понимает: ясность превыше всего. Профессионалы используют свою силу во благо и пишут код, понятный для других людей. 

**Имена классов**

Имена классов и объектов должны представлять собой существительные и их 
комбинации: Customer, WikiPage, Account и AddressParser. Старайтесь не использовать в именах классов такие слова, как Manager, Processor, Data или Info. Имя класса не должно быть глаголом.

**Имена методов**

Имена методов представляют собой глаголы или глагольные словосочетания: 
`postPayment, deletePage, save` и т. д. 

При перегрузке конструкторов используйте статические методы-фабрики с  
именами, описывающими аргументы. Например, запись 
`Complex fulcrumPoint = Complex.FromRealNumber(23.0);` 
обычно лучше записи 
`Complex fulcrumPoint = new Complex(23.0);` 
Рассмотрите возможность принудительного использования таких методов; для 
этого соответствующие конструкторы объявляются приватными. 

**Избегайте остроумия**

Если ваши имена будут излишне остроумными, то их смысл будет понятен только людям, разделяющим чувство юмора автора—и только если они помнят шутку.

**Выберите одно слово для каждой концепции**

Выберите одно слово для представления одной абстрактной концепции и придерживайтесь его. Например, существование в разных классах эквивалентных методов с именами fetch, retrieve и get неизбежно создаст путаницу. 

Имена функций должны быть законченными и логичными, чтобы программист мог сразу выбрать правильный метод без сбора дополнительной информации. 

Аналогичным образом, использование терминов controller, manager и driver в одной кодовой базе тоже вызывает путаницу.

Единый, согласованный лексикон окажет неоценимую помощь программистам, которые будут пользоваться вашим кодом.

**Воздержитесь от каламбуров**

Старайтесь не использовать одно слово в двух смыслах. В сущности, обозначение двух разных идей одним термином — это каламбур.

... Вы пишете новый класс с методом, помещающим свой единственный параметр в коллекцию. ... в программе уже используется множество других методов add, но новый метод имеет другую семантику, поэтому ему лучше присвоить имя i nsert или append. Присваивая новому методу имя add, вы создаете нежелательный каламбур.

Код должен  восприниматься с первого взгляда, не требуя тщательного изучения. 

**Используйте имена из пространства решения**

Не забывайте: ваш код будут читать программисты. А раз так, не стесняйтесь использовать термины из области информатики, названия алгоритмов и паттернов, математические термины и т. д. Не ограничивайтесь именами исключительно из пространства задачи; не заставляйте своих коллег постоянно бегать к  клиенту и спрашивать, что означает каждое имя, когда соответствующая концепция 
уже знакома им под другим названием. 
Имя AccountVisitor сообщит много полезной информации программисту, знакомому с паттерном «Посетитель» (Visitor).

Существует множество сугубо технических понятий, с которыми имеют дело программисты. Как правило, таким понятиям разумнее всего присваивать технические имена.

**Используйте имена из пространства задачи**

Если для того, что вы делаете, не существует подходящего «программизма», используйте имя из пространства задачи.

Разделение концепций из пространств задачи и решения — часть работы хорошего программиста и проектировщика. В коде, главным образом ориентированном на концепции из пространства задачи, следует использовать имена из пространства задачи.

**Добавьте содержательный контекст**

Лишь немногие имена содержательны сами по себе. Все остальные имена следует помещать в определенный контекст для читателя кода, заключая их в классы, 
функции и пространства имен с правильно выбранными названиями. В крайнем 
случае контекст имени можно уточнить при помощи префикса.

Уточнение контекста также позволяет заметно улучшить четкость алгоритма за счет его деления на меньшие функции.

**He добавляйте избыточный контекст**

Короткие имена обычно лучше длинных, если только их смысл понятен  читателю кода. Не включайте в имя больше контекста, чем необходимо.

Имена accountAddress и customerAddress хорошо подходят для экземпляров класса 
Address, но для классов такой выбор неудачен. Address — вот хорошее имя класса. 
Если потребуется подчеркнуть различия между МАС-адресами, адресами портов 
и веб-адресами, я подумаю об использовании имен PostalAddress, MAC и URI.  
Полученные имена становятся более точными, а это, собственно, и является главной 
целью всего присваивания имен. 

**Несколько слов напоследок**

Основные трудности с выбором хороших имен обусловлены необходимостью хороших описательных навыков и единого культурного фона. 

Возможно, своими переименованиями — как и любыми другими усовершенствованиями кода — вы кого-то удивите. Пусть это вас не останавливает. 

## Глава 3. Функции

На заре эпохи программирования системы строились из программ, функций 
и подпрограмм. До наших дней дожили только функции. Они образуют первый 
уровень структуризации в любой программе.

**Компактность!**

Первое правило: функции должны быть компактными. Второе правило: функции 
должны быть еще компактнее.

Желательно, чтобы длина функции не превышала 20 строк. 

Все функции были предельно очевидными. Каждая функция излагала свою историю, и каждая история естественным образом подводила вас к началу следующей истории. Вот какими короткими должны быть функции! 

*Блоки и отступы*

Из сказанного выше следует, что блоки в командах if, else, while и т. д. должны 
состоять из одной строки, в которой обычно содержится вызов функции. 

Максимальный уровень отступов в функции не должен превышать одного-двух. Разумеется, это упрощает чтение и понимание функций. 

**Правило одной операции**

ФУНКЦИЯ ДОЛЖНА ВЫПОЛНЯТЬ ТОЛЬКО ОДНУ ОПЕРАЦИЮ. ОНА ДОЛЖНА ВЫПОЛНЯТЬ ЕЕ ХОРОШО. И НИЧЕГО ДРУГОГО ОНА ДЕЛАТЬ НЕ ДОЛЖНА. 

Если функция выполняет только те действия, которые находятся на одном  уровне под объявленным именем функции, то эта функция выполняет одну операцию. 

Итак, чтобы определить, что функция выполняет более одной операции,  попробуйте извлечь из нее другую функцию, которая бы не являлась простой переформулировкой реализации.

Функцию, выполняющую только одну операцию, невозможно осмысленно разделить на секции.

**Один уровень абстракции на функцию**

Чтобы убедиться в том, что функция выполняет «только одну операцию», необходимо проверить, что все команды функции находятся на одном уровне абстракции. 

Смешение уровней абстракции внутри функции всегда создает путаницу.  
Читатель не всегда понимает, является ли некоторое выражение важной концепцией 
или второстепенной подробностью. Что еще хуже, при их смешении функция 
постепенно начинает обрастать все большим количеством второстепенных  
подробностей.

*Чтение кода сверху вниз: правило понижения*

Код должен читаться как рассказ — сверху вниз

За каждой функцией должны следовать функции следующего уровня  
абстракции. Это позволяет читать код, последовательно спускаясь по уровням  
абстракции в ходе чтения списка функций. Я называю такой подход «правилом 
понижения». 

Опыт показывает, что программистов очень трудно научить следовать этому 
правилу и писать функции, остающиеся на одном уровне абстракции. Тем не 
менее освоить этот прием очень важно. Он играет ключевую роль для создания 
коротких функций, выполняющих только одну операцию.

**Команды switch**

К сожалению, обойтись без команд switch удается не всегда, но по 
крайней мере мы можем позаботиться о том, чтобы эти команды были скрыты 
в низкоуровневом классе и не дублировались в коде. И конечно, в этом нам может 
помочь полиморфизм. 

Решение проблемы (листинг 3.5) заключается в том, чтобы похоронить команду 
switch в фундаменте АБСТРАКТНОЙ ФАБРИКИ [GOF] и никому ее не  
показывать. Фабрика использует команду switch для создания соответствующих  
экземпляров потомков 

Мое общее правило в отношении команд switch гласит, что эти команды допустимы, если они встречаются в программе однократно, используются для создания полиморфных объектов и скрываются за отношениями наследования, чтобы 
оставаться невидимыми для остальных частей системы.

**Используйте содержательные имена**

Вспомните принцип Уорда: «Вы работаете с чистым кодом, если каждая функция в основном делает то, что вы от нее ожидали». 

Чем меньше и специализированнее функция, тем проще выбрать для нее содержательное имя. 

Выбор содержательных имен прояснит архитектуру модуля и поможет вам 
усовершенствовать ее. Нередко поиски хороших имен приводят к полезной  
реструктуризации кода. 

Будьте последовательны в выборе имен. Используйте в именах функций те 
же словосочетания, глаголы и существительные, которые используются в  
ваших модулях. 

**Аргументы функций**

В идеальном случае количество аргументов функции равно нулю (нуль-арная 
функция). Далее следуют функции с одним аргументом (унарные) и с двумя 
аргументами (бинарные). Функций с тремя аргументами (тернарных) следует по 
возможности избегать. Необходимость функций с большим количеством аргументов (полиарных) должна быть подкреплена очень вескими доводами — и все равно такие функции лучше не использовать. 

Аргументы усложняют функции и лишают их значительной части концептуальной мощи. 

Аргумент и имя функции находятся на разных уровнях абстракции, а читателю приходится помнить о подробностях.

Если же аргументов больше двух,  задача тестирования всех возможных комбинаций выглядит все более устрашающе. 

Выходные аргументы запутывают ситуацию еще быстрее, чем входные. ... Как правило, никто не ожидает, что функция будет возвращать информацию в аргументах.

*Стандартные унарные формы*

Существует два очень распространенных случая вызова функции с одним  
аргументом. Первая — проверка некоторого условия, связанного с аргументом, 
как в вызове `boolean fileExists("MyFile")`. Вторая — обработка аргумента, его 
преобразование и возвращение. 

Несколько менее распространенным, но все равно очень полезным частным 
случаем функции с одним аргументом является событие. В этой форме имеется 
входной аргумент, а выходного аргумента нет. Предполагается, что программа 
интерпретирует вызов функции как событие и использует аргумент для  
изменения состояния системы, например, `void passwordAttemptFai1edNtimes(int attempts)`. 
Будьте внимательны при использовании данной формы. Читателю должно быть 
предельно ясно, что перед ним именно событие. Тщательно выбирайте имена 
и контексты. 

Старайтесь избегать унарных функций, не относящихся к этим формам.

*Аргументы-флаги*

Аргументы-флаги уродливы. ... усложняет сигнатуру метода, громко 
провозглашая, что функция выполняет более одной операции. ... Эту функцию следовало бы разбить на две...

*Бинарные функции*

...никакие части кода игнорироваться не должны. Именно в проигнорированных частях чаще всего скрываются ошибки. 

Конечно, в некоторых ситуациях форма с двумя аргументами оказывается 
уместной. Например, вызов Point р = new Point(0,0); абсолютно разумен. Точка 
в декартовом пространстве естественным образом создается с двумя аргументами. 

Даже с очевидными бинарными функциями вида assertEquals(expected, actual) 
возникают проблемы. Сколько раз вы помещали actual туда, где должен был  
находиться аргумент expected? 

Бинарные функции не являются абсолютным злом, и вам почти наверняка придется писать их. Тем не менее следует помнить, что за их использование приходится расплачиваться...

*Тернарные функции*

Разобраться в функции с тремя аргументами значительно сложнее, чем в  
бинарной функции. Проблемы соблюдения порядка аргументов, приостановки чтения 
и игнорирования увеличиваются более чем вдвое. Я рекомендую очень хорошо 
подумать, прежде чем создавать тернарную функцию. 

*Объекты как аргументы*

Если функция должна получать более двух или трех аргументов, весьма вероятно, что некоторые из этих аргументов стоит упаковать в отдельном классе.

Если переменные передаются совместно как единое целое, то, скорее всего, вместе они образуют концепцию, заслуживающую собственного имени. 

*Списки аргументов*

...все переменные аргументы считаются равноправными ... их совокупность эквивалентна одному аргументу типа List. По этой причине функция `String.format` фактически является бинарной. 

Функции с переменным списком аргументов могут быть унарными, бинарными и даже 
тернарными, но использовать большее количество аргументов было бы ошибкой. 

*Глаголы и ключевые слова*

Выбор хорошего имени для функции способен в значительной мере объяснить 
смысл функции, а также порядок и смысл ее аргументов. В унарных функциях 
сама функция и ее аргумент должны образовывать естественную пару «глагол/существительное». Например, вызов вида `write(name)` смотрится весьма информативно. ... Еще лучше запись `writeField(name)`...

... имена аргументов кодируются в имени функции. Например, assertEquals можно записать в виде `assertExpectedEqualsActual (expected, actual)`. Это в значительной мере решает проблему запоминания порядка аргументов. 

**Избавьтесь от побочных эффектов**

Побочные эффекты суть ложь. Ваша функция обещает делать что-то одно, но делает что-то другое, скрытое от пользователя. Иногда она вносит неожиданные изменения в переменные своего класса — скажем, присваивает им значения параметров, переданных функции, или глобальных переменных системы. В любом случае 
такая функция является коварной и вредоносной ложью, которая часто приводит 
к созданию противоестественных временных привязок и других зависимостей.

*Выходные аргументы*

Аргументы естественным образом интерпретируются как входные данные  функции. 

Все, что заставляет обращаться к сигнатуре функции, нарушает естественный ритм чтения кода. Подобных «повторных заходов» следует избегать. 

До наступления эпохи объектно-ориентированного программирования без выходных аргументов иногда действительно не удавалось обойтись. Но в ОО-языках 
эта проблема в целом исчезла, потому что сама функция может вызываться для 
выходного аргумента. 

В общем случае выходных аргументов следует избегать. Если ваша функция 
должна изменять чье-то состояние, пусть она изменяет состояние своего объекта- 
владельца. 

**Разделение команд и запросов**

Функция должна что-то делать или отвечать на какой-то вопрос, но не одновременно. Либо функция изменяет состояние объекта, либо возвращает информацию об этом объекте. Совмещение двух операций часто создает путаницу. 

Это приводит к появлению странных конструкций вида 
`if (set("username". "unclebob"))... `

Полноценное решение заключается в отделении команды от запроса, чтобы 
в принципе исключить любую неоднозначность.

```
if (attributeExists("username")) { 
    setAttribute("username". "unciebob"); 
    ...
} 
```

**Используйте исключения вместо возвращения кодов ошибок**

Возвращение кодов ошибок функциями-командами является неочевидным нарушением принципа разделения команд и запросов. Оно поощряет использование 
команд в предикатных выражениях if.

С другой стороны, если вместо возвращения кодов ошибок используются исключения, то код обработки ошибок изолируется от ветви нормального выполнения и упрощается

*Изолируйте блоки try/catch*

Блоки try/catch выглядят весьма уродливо. Они запутывают структуру кода 
и смешивают обработку ошибок с нормальной обработкой. По этой причине тела 
блоков try и catch рекомендуется выделять в отдельные функции. 

*Обработка ошибок как одна операция*

Функции должны выполнять одну операцию. Обработка ошибок — это одна 
операция. Значит, функция, обрабатывающая ошибки, ничего другого делать не 
должна. Отсюда следует, что если в функции присутствует ключевое слово` try`, 
то оно должно быть первым словом в функции, а после блоков `catch/finallу` ничего другого быть не должно. 

*Магнит зависимостей Error.java*

Возвращение кода ошибки обычно подразумевает, что в программе имеется некий класс или перечисление, в котором определяются все коды ошибок. 

Подобные классы называются "магнитами зависимостей", они должны импортироваться и использоваться многими другими классами. 

Если вместо кодов ошибок использовать исключения, то новые исключения 
определяются производными от класса исключения. Их включение в программу 
не требует перекомпиляции или повторного развертывания (Пример принципа открытости/закрытости (ОСР)). 

**Не повторяйтесь (Принцип DRY)**

дублирование создает проблемы,  потому что оно увеличивает объем кода, а при изменении алгоритма вам придется вносить изменения сразу в четырех местах. Также вчетверо возрастает  вероятность ошибки. 

Дублирование иногда считается корнем всего зла в программировании. .... Структурное программирование, аспектно-ориентированное программирование, компонентно-ориентированное программирование — все эти технологии отчасти являются стратегиями борьбы с дублированием. Похоже, с момента изобретения подпрограмм все новшества в разработке программного обеспечения были направлены исключительно на борьбу с дублированием в исходном коде. 

**Структурное программирование**

Некоторые программисты следуют правилам структурного программирования, 
изложенным Эдгаром Дейкстрой [SP72]. Дейкстра считает, что каждая функция 
и каждый блок внутри функции должны иметь одну точку входа и одну точку 
выхода. Выполнение этого правила означает, что функция должна содержать 
только одну команду return, в циклах не должны использоваться команды break 
или conti nue, а команды goto не должны использоваться никогда и ни при каких 
условиях. 

... если ваши функции остаются очень компактными, редкие вкрапления множественных return, команд break и conti nue не принесут вреда, а иногда даже повышают выразительность по сравнению с классической реализацией с одной точкой входа и одной точкой выхода. С другой стороны, команда goto имеет смысл только в больших функциях, поэтому ее следует избегать.

**Завершение**

...функции играют роль глаголов, а классы — существительных.

Искусство программирования является (и всегда было)  искусством языкового проектирования. 

Опытные программисты рассматривают систему как историю, которую они 
должны рассказать, а не как программу, которую нужно написать. 

Если вы будете следовать этим правилам, ваши функции будут короткими, удачно названными и хорошо организованными. Но никогда не забывайте, что ваша настоящая цель — «рассказать историю» системы, а написанные вами функции должны четко складываться в понятный и точный язык, который поможет вам в этом. 

## Глава 4. Комментарии

Ничто не помогает так, как уместный комментарий. Ничто не загромождает модуль так, как бессодержательные и безапелляционные комментарии.

Комментарии в лучшем случае являются неизбежным злом. 

Комментарий — всегда признак неудачи.

Программисты не могут нормально сопровождать комментарии. 

Истину можно найти только в одном месте: в коде. Только код может правдиво сообщить, что он делает. 

*Комментарии не компенсируют плохого кода*

Не тратьте время на написание комментариев, объясняющих созданную вами путаницу, — лучше потратьте его на исправление. 

*Объясните свои намерения в коде*

Нередко задача сводится с созданию функции, которая сообщает то же, что и комментарий, который вы собираетесь написать.

**Хорошие комментарии**

*Юридические комментарии*

Ограничьтесь ссылкой на стандартную лицензию или другой внешний документ. 

*Информативные комментарии*

Например комментарий поясняющий регулярное выражение. И все же код стал бы лучше (и понятнее), если бы мы переместили этот код в специальный класс.

*Предупреждения о последствиях*
Иногда бывает полезно предупредить других программистов о нежелательных последствиях от каких-либо действий. 

*Комментарии TODO*

Комментарии TODO напоминают о том, что, по мнению программиста, сделать необходимо, но по какой-то причине нельзя сделать прямо сейчас. 

Регулярно просматривайте их и удаляйте те, которые потеряли актуальность. 

*Усиление* 
Комментарий может подчеркивать важность обстоятельства, которое на первый 
взгляд кажется несущественным.

*Комментарии Javadoc в общедоступных API* 

Если вы разрабатываете API для общего пользования, несомненно, для него 
следует написать хорошие комментарии Javadoc. Однако не забывайте об остальных 
советах этой главы. Комментарии Javadoc могут быть такими же и  недостоверными и лживыми, как и любые другие комментарии.

**Плохие комментарии**

*Бормотание*

Не стоит лепить комментарии «на скорую руку» только потому, что вам  кажется, что это уместно или этого требует процесс.

Любой комментарий, смысл которого приходится искать в  других модулях, не несет полезной информации и не стоит битов, затраченных на его написание. 

*Избыточные комментарии*

Он напоминает жуликоватого торговца подержанными машинами, уверяющего, что вам незачем заглядывать под капот. 

Эти комментарии только  загромождают код и скрывают его смысл. Никакой пользы для документирования от них нет. 

*Недостоверные комментарии*

Иногда с самыми лучшими намерениями программист делает в комментариях заявления, неточные и не соответствующие истине. 

*Обязательные комментарии*

Правила, говорящие, что каждая функция должна иметь комментарий Javadoc 
или что каждая переменная должна быть помечена комментарием, — обычная 
глупость. Такие комментарии только загромождают код, распространяют недостоверную информацию и вызывают общую путаницу и дезориентацию. 

Они только запутывают код, повышая риск обмана и недоразумений. 

*Журнальные комментарии* 

Их наличие было оправдано в догитовские времена. 

В наши дни длинные журналы только загромождают и усложняют код.

*Шум*

Они лишь утверждают очевидное, не предоставляя никакой новой информации. 

Эти комментарии настолько бесполезны, что мы учимся не обращать на них внимания

Искушение создать очередной «шумовой комментарий» следует заменить решимостью очистить код. 

*Опасный шум*

Это избыточные шумовые комментарии,  вызванные неуместным желанием как-то документировать свои действия.

*Не используйте комментарии там, где можно использовать функцию или переменную* 

*Позиционные маркеры*

Взгляните на дело под таким углом: заголовки привлекают внимание только в том случае, если они встречаются не слишком часто. Используйте их умеренно и только тогда, когда они приносят ощутимую пользу. При слишком частом потреблении заголовков читатель воспринимает их как фоновый шум и перестает обращать на них внимание. 

*Комментарии за закрывающей фигурной скобкой*

Применение таких комментариев оправдано в длинных функциях с многоуровневой вложенностью, но они только загромождают компактные специализированные функции, которым мы отдает предпочтение. Итак, если у вас возникает желание прокомментировать  закрывающие фигурные скобки, лучше постарайтесь укоротить свои функции. 

*Ссылки на авторов*

Лучшим источником подобной информации является система контроля исходного кода. 

*Закомментированный код*

В 60-е годы закомментированный код мог быть действительно полезен. Но с тех пор у нас давно появились хорошие системы контроля исходного кода. Эти системы запоминают изменения в коде за нас. Нам уже не нужно закрывать их комментариями. Просто удалите ненужный код. Он никуда не исчезнет. Честное слово. 

*Комментарии HTML*

Он затрудняет чтение комментариев именно там, где они должны легко читаться — в редакторе/IDE. 

*Нелокальная информация*

Если вы должны написать комментарий, проследите за тем, чтобы он описывал 
находящийся поблизости код. Не излагайте информацию системного уровня 
в контексте локального комментария. 

```
/** 
* Порт, на котором будет работать fitnesse. По умолчанию <b>8082</b>. 
* 
* @param fitnessePort 
*/ 
public void setFitnessePort(int fitnessePort) 
{ 
this.fitnessePort = fitnessePort; 
} 
```

*Слишком много информации*

Не включайте в комментарии интересные исторические дискуссии или  описания подробностей, не относящиеся к делу. 

... вполне достаточно номера RFC. 

*Неочевидные комментарии*

Связь между комментарием и кодом, который он описывает, должна быть очевидной. 

Цель  комментария — объяснить код, который не объясняет сам себя. Плохо, когда сам комментарий нуждается в объяснениях.

*Заголовки функций*

Короткие функции не нуждаются в долгих описаниях. Хорошо выбранное имя компактной функции, которая выполняет одну операцию, обычно лучше заголовка с комментарием. 

*Заголовки Javadoc во внутреннем коде*

При всей полезности комментариев Javadoc для API общего пользования не 
применяйте их в коде, не предназначенном для общего потребления. 
Генерирование страниц Javadoc для внутренних классов и функций системы обычно не приносит реальной пользы, а формализм комментариев Javadoc только отвлекает 
читателя. 

## Глава 5. Форматирование

Вы должны позаботиться о том, чтобы ваш код был хорошо отформатирован. 
Выберите набор простых правил, определяющих формат кода, и последовательно применяйте их в своей работе. Если вы работаете в составе группы, то группа 
должна выработать согласованный набор правил форматирования, соблюдаемых 
всеми участниками. Также полезно иметь средства автоматизации, которые применяют правила форматирования за вас. 

**Цель форматирования**

... форматирование кода важно. Оно слишком важно, чтобы не обращать на него внимания, и слишком важно, чтобы относиться к нему с религиозным пылом. Форматирование кода направлено на передачу информации, а передача информации является первоочередной задачей профессионального разработчика. 

... удобочитаемость вашего кода окажет сильное воздействие на все изменения, которые когда-либо будут внесены. Стиль кодирования и удобочитаемость создают прецеденты, которые продолжают влиять на сопровождаемость и расширяемость 
кода уже после того, как исходный код изменился до неузнаваемости. Стиль и дисциплина программирования продолжают жить, даже если ваш код остался в прошлом. 

**Вертикальное форматирование**

... типичная длина которых составляет 200 строк, с верхним пределом в 500 строк. Хотя это не должно считаться раз и навсегда установленным правилом, такие показатели весьма желательны. Маленькие файлы обычно более понятны, чем большие. 

*Газетная метафора*

Исходный файл должен выглядеть как газетная статья. Имя файла должно быть 
простым, но содержательным. Одного имени должно быть достаточно для того, 
чтобы читатель понял, открыл ли он нужный модуль или нет. Начальные блоки 
исходного файла описывают высокоуровневые концепции и алгоритмы. Степень 
детализации увеличивается при перемещении к концу файла, а в самом конце 
собираются все функции и подробности низшего уровня в исходном файле. 

*Вертикальное разделение концепций*

Практически весь код читается слева направо и сверху вниз. Каждая строка представляет выражение или условие, а каждая группа строк представляет законченную мысль. Эти мысли следует отделять друг от друга пустыми строками. 

... второй пример выглядит как сплошная каша, притом что два листинга различаются только вертикальными разделителями. 

*Вертикальное сжатие*

Если вертикальные пропуски разделяют концепции, то вертикальное сжатие подчеркивает тесные связи. Таким образом, строки кода, между которыми существует тесная связь, должны быть «сжаты» по вертикали. Обратите внимание на то, как бесполезные комментарии в листинге 5.3 нарушают группировку двух переменных экземпляров. 

*Вертикальные расстояния*

Концепции, тесно связанные друг с другом, должны находиться поблизости друг 
от друга по вертикали [G10]. Разумеется, это правило не работает для концепций, 
находящихся в разных файлах. Но тесно связанные концепции и не должны 
находиться в разных файлах, если только это не объясняется очень вескими  
доводами. Кстати, это одна из причин, по которой следует избегать защищенных 
переменных. 
Если концепции связаны настолько тесно, что они находятся в одном исходном 
файле, их вертикальное разделение должно показывать, насколько они важны 
для понимания друг друга. Не заставляйте читателя прыгать туда-сюда по  
исходным файлам и классам. 

<u>Объявления переменных.</u> Переменные следует объявлять как можно ближе 
к месту использования. Так как мы имеем дело с очень короткими функциями, 
локальные переменные должны перечисляться в начале каждой функции...

В отдельных случаях переменная может объявляться в начале блока или непосредственно перед циклом в длинной функции. 

<u>Переменные экземпляров</u>

должны объявляться в начале класса. Это не увеличивает вертикальное расстояние между переменными, потому что в хорошо спроектированном классе они используются многими, если не всеми, методами класса. 

<u>Зависимые функции</u>

Если одна функция вызывает другую, то эти функции должны располагаться вблизи друг от друга по вертикали, а вызывающая функция должна находиться над вызываемой (если это возможно). 

<u>Концептуальное родство</u>

Некоторые фрагменты кода требуют, чтобы их разместили вблизи от других фрагментов. Такие фрагменты обладают определенным концептуальным родством. Чем сильнее родство, тем меньше должно быть вертикальное расстояние между ними. 
Как мы уже видели, родство может быть основано на прямой зависимости (когда одна функция вызывает другую) или на использовании переменных в функциях. Однако существуют и другие разновидности родства. 

<u>Вертикальное упорядочение</u>

Как правило, взаимозависимые функции должны размещаться в нисходящем 
порядке. Иначе говоря, вызываемая функция должна располагаться ниже  
вызывающей функции. Так формируется логичная структура модуля исходного 
кода - от высокого уровня к более низкому. 

... Это позволяет нам бегло просматривать исходные файлы, извлекая суть из нескольких начальных функций, без погружения в подробности. 

**Горизонтальное форматирование**

ничего не имеют против строк длиной в 100 и даже 120 символов. Но более длинные строки, вероятно, вызваны небрежностью программиста.

*Горизонтальное разделение и сжатие*

Знаки присваивания окружены пробелами, обеспечивающими их визуальное 
выделение. Операторы присваивания состоят из двух основных элементов: левой 
и правой частей. Пробелы наглядно подчеркивают это разделение. 

С другой стороны, я не стал отделять имена функций от открывающих скобок. Это обусловлено тем, что имя функции тесно связано с ее аргументами. Пробелы изолируют их вместо того, чтобы объединять. Я также разделил аргументы в скобках пробелами, чтобы выделить запятые и подчеркнуть, что аргументы не зависят друг от друга. 

*Горизонтальное выравнивание*

Если в программе встречаются длинные списки, нуждающиеся в выравнивании, то 
проблема кроется в длине списка, а не в отсутствии выравнивания. 

*Отступы*

Команды уровня файла (такие, как большинство объявлений классов) отступов 
не имеют. Методы в классах сдвигаются на один уровень вправо от уровня  
класса. Реализации этих методов сдвигаются на один уровень вправо от объявления 
класса. Реализации блоков сдвигаются на один уровень вправо от своих внишних 
блоков и т. д. 

... Без отступов программа становится практически нечитаемой для людей. 

Иногда возникает соблазн нарушить правила расстановки отступов в коротких командах if, коротких циклах while или коротких функциях. Но каждый раз, когда я поддавался этому искушению, я почти всегда возвращался и расставлял отступы, как положено. Таким образом, я стараюсь не сворачивать блоки в одну строку

*Вырожденные области видимости*

Иногда тело цикла whilе или команды for не содержит команд, то есть является 
вырожденным, как в следующем фрагменте. Я не люблю такие структуры и  
стараюсь избегать их. А когда это невозможно, я по крайней мере слежу за тем, чтобы 
пустое тело имело правильные отступы и было заключено в фигурные скобки. 

**Правила форматирования в группах**

Код программного продукта должен быть оформлен в едином стиле. Он не должен выглядеть так, словно был написан несколькими личностями, расходящимися во мнениях по поводу оформления. 

... Мы решили, где будем расставлять фигурные скобки, каким будет размер отступов, по какой схеме будут присваиваться имена классов, переменных и методов и т. д. 

... Хорошая программная система состоит из набора удобочитаемых документов, 
оформленных в едином, согласованном стиле. 

## Глава 6. Объекты и структуры данных

Существует веская причина для ограничения доступа к переменным в  
программах: мы не хотим, чтобы другие программисты зависели от них. Мы хотим иметь возможность свободно менять тип или реализацию этих переменных так, как 
считаем нужным. Тогда почему же многие программисты автоматически  
включают в свои объекты методы чтения/записи, предоставляя доступ к приватным 
переменным так, словно они являются открытыми? 

**Абстракция данных**

Скрытие реализации не сводится к созданию прослойки функций между переменными. Скрытие реализации направлено на формирование абстракций! Класс 
не просто ограничивает доступ к переменным через методы чтения/записи. 
Вместо этого он предоставляет абстрактные интерфейсы, посредством которых пользователь оперирует с сущностью данных. Знать, как эти данные реализованы, ему при этом не обязательно. 

... Чтобы найти  лучший способ представления данных, содержащихся в объекте, необходимо серьезно поразмыслить. Бездумное добавление методов чтения и записи — худший из всех возможных вариантов. 

**Антисимметрия данных/объектов**

Объекты скрывают свои данные за абстракциями и предоставляют функции, 
работающие с этими данными. Структуры данных раскрывают свои данные и не 
имеют осмысленных функций. А теперь еще раз перечитайте эти определения. 
Обратите внимание на то, как они дополняют друг друга, фактически являясь 
противоположностями. Различия могут показаться тривиальными, но они  
приводят к далеко идущим последствиям. 

*Процедурный код (код, использующий структуры данных) позволяет легко 
добавлять новые функции без изменения существующих структур данных. Объектно - ориентированный код, напротив, упрощает добавление новых классов без  изменения существующих функций.*
Обратные утверждения также истинны. 
*Процедурный код усложняет добавление новых структур данных, потому что оно 
требует изменения всех функций. Объектно-ориентированный код усложняет 
добавление новых функций, потому что для этого должны измениться все классы.* 
Таким образом, то, что сложно в ОО, просто в процедурном программировании, 
а то, что сложно в процедурном программировании, просто в ОО! 

В любой сложной системе возникают ситуации, когда вместо новых функций 
в систему требуется включить новые типы данных. Для таких ситуаций объекты 
и объектно-ориентированное программирование особенно уместны. Впрочем, 
бывает и обратное — вместо новых типов данных требуется добавить новые 
функции. Тогда лучше подходит процедурный код и структуры данных. 

Опытные программисты хорошо знают: представление о том, что все данные 
должны представляться в виде объектов — миф. Иногда предпочтительны  простые структуры данных и процедуры, работающие с ними.

**Закон Деметры**

Хорошо известное эвристическое правило, называемое законом Деметры, гласит, 
что модуль не должен знать внутреннее устройство тех объектов, с которыми он 
работает. 

В более точной формулировке закон Деметры гласит, что метод F класса С должен 
ограничиваться вызовом методов следующих объектов: 

- С; 

- объекты, созданные F; 

- объекты, переданные F в качестве аргумента; 

- объекты, хранящиеся в переменной экземпляра С. 

Метод не должен вызывать методы объектов, возвращаемых любыми из разрешенных функций. 

*Крушение поезда*

Подобная структура кода часто называется «крушением поезда», потому что 
цепочки вызовов напоминают сцепленные вагоны поезда. Такие конструкции считаются проявлением небрежного стиля программирования и их следует избегать [G36]. Обычно цепочки лучше разделить в следующем виде: 
`Options opts = ctxt.getOptions(); 
File scratchDir = opts.getScratchDir(); 
final String outputDir = scratchDir.getAbsolutePath(); `
Нарушают ли эти два фрагмента закон Деметры? Несомненно, вмещающий модуль знает, что объект контекста ctxt содержит значения параметров, в число которых входит и временный каталог, обладающий абсолютным путем. 

Нарушает ли этот код закон Деметры или нет? Все зависит от того, чем являются 
ctxt, Options и ScratchDir — объектами или структурами данных. Если это  
объекты, то их внутренняя структура должна скрываться, поэтому необходимость 
информации об их строении является явным нарушением закона Деметры. 
С другой стороны, если ctxt, Options и ScratchDir представляют собой обычные 
структуры данных, не обладающие поведением, то они естественным образом 
раскрывают свою внутреннюю структуру, а закон Деметры на них не  
распространяется. 

*Гибриды*

Вся эта неразбериха иногда приводит к появлению гибридных структур —  
наполовину объектов, наполовину структур данных. Гибриды содержат как функции 
для выполнения важных операций, так и открытые переменные или открытые 
методы чтения/записи, которые во всех отношениях делают приватные  
переменные открытыми. Другим внешним функциям предлагается использовать эти переменные так, как в процедурных программах используются структуры данных. 
Подобные гибриды усложняют как добавление новых функций, так и новых 
структур данных. Они объединяют все худшее из обеих категорий. Не  
используйте гибриды. Они являются признаком сумбурного проектирования, авторы 
которого не уверены (или еще хуже, не знают), что они собираются защищать: 
функции или типы. 

*Скрытие структуры*

Если ctxt является объектом, то мы должны приказать ему выполнить некую операцию, а не запрашивать у него информацию о его внутреннем устройстве. 

... Такое решение позволяет объекту ctxt скрыть свое внутреннее строение, а текущей функции не приходится нарушать закон Деметры, перемещаясь между объектами, о которых ей знать не положено. 

*Объекты передачи данных*

Квинтэссенцией структуры данных является класс с открытыми переменными и без функций. Иногда такие структуры называются объектами передачи данных, или DTO (Data Transfer Object). ... С них часто начинается серия фаз преобразования низкоуровневых данных, полученных из базы, в объекты кода приложения. 

Веаn-компоненты состоят из приватных переменных, операции с которыми осуществляются при помощи методов чтения/записи. Подобная форма псевдоинкапсуляции поднимает настроение некоторым блюстителям чистоты ОО, но обычно не имеет других преимуществ. 

*Активные записи*

Активные записи (Active Records) составляют особую разновидность DTO. Они тоже представляют собой структуры данных с открытыми переменными (или переменными с bean-доступом), но обычно в них присутствуют навигационные методы — такие, как save или find.

К сожалению, разработчики часто пытаются интерпретировать такие структуры данных, как объекты, и включают в них методы, реализующие бизнес-логику. Однако такой подход нежелателен, так как он создает гибрид между структурой данных и объектом. 

**Заключение**

Объекты предоставляют поведение и скрывают данные. Это позволяет программисту легко добавлять новые виды объектов, не изменяя существующего поведения. С другой стороны, объекты усложняют добавление нового поведения к существующим объектам. Структуры данных предоставляют данные, но не обладают сколько-нибудь значительным поведением. Они упрощают добавление нового поведения в существующие структуры данных, но затрудняют добавление новых структур данных в существующие функции. 
Если в некоторой системе нас прежде всего интересует гибкость в добавлении 
новых типов данных, то в этой части системы предпочтение отдается объектной 
реализации. В других случаях нам нужна гибкость расширения поведения, и тогда в этой части используются типы данных и процедуры. Хороший программист относится к этой проблеме без предубеждения и выбирает то решение, которое лучше всего подходит для конкретной ситуации. 

## Глава 7. Обработка ошибок

... связь этих двух тем — обработки ошибок и чистого кода — очевидна. 

... из-за разбросанной повсюду обработки ошибок практически невозможно понять, что же делает код. Обработка ошибок важна, но если они заслоняют собой логику программы — значит, она реализована неверно. 

**Используйте исключения вместо кодов ошибок**

... они загромождают код на стороне вызова. Вызывающая сторона должна проверять ошибки немедленно после  вызова. К сожалению, об этом легко забыть. По этой причине при обнаружении ошибки лучше инициировать исключение. Код вызова становится более понятным, а его логика не скрывается за кодом обработки ошибок.

**Начните с написания команды try-catch-finally**

У исключений есть одна интересная особенность: они определяют область  
видимости в вашей программе. Размещая код в секции try команды try-catch-final 1у, 
вы утверждаете, что выполнение программы может прерваться в любой точке, 
а затем продолжиться в секции catch. 
Блоки try в каком-то отношении напоминают транзакции. Секция catch должна 
оставить программу в целостном состоянии, что бы и произошло в секции try. 
По этой причине написание кода, который может инициировать исключения,  
рекомендуется начинать с конструкции try-catch-final 1у. Это поможет вам  
определить, чего должен ожидать пользователь кода, что бы ни произошло в коде try. 

**Используйте непроверяемые исключения**

В С# нет проверяемых исключений, и несмотря на все доблестные попытки, в C++ они так и не появились. Их также нет в Python и Ruby. Тем не менее на всех этих языках можно писать надежные программы. А раз так, нам приходится решать, оправдывают ли проверяемые исключения ту цену, которую за них приходится платить. 

Цена проверяемых исключений — нарушение  принципа открытости/закрытости [Martin]. Если вы инициируете проверяемое исключение из метода своего кода, a catch находится тремя уровнями выше, то это исключение должно быть объявлено в сигнатурах всех методов между вашим методом и catch. Следовательно, изменение на низком уровне программного продукта приводит к изменениям сигнатур на многих более высоких уровнях. 

Проверяемые исключения иногда могут пригодиться при написании особо важных библиотек: программист обязан перехватить их. Но в общем случае разработки приложений проблемы, создаваемые зависимостями, перевешивают преимущества. 

**Передавайте контекст с исключениями**

Каждое исключение, инициируемое в программе, должно содержать достаточно 
контекстной информации для определения источника и местонахождения ошибки. В Java из любого исключения можно получить данные трассировки стека; 
однако по трассировке невозможно узнать, с какой целью выполнялась операция, 
завершившаяся неудачей. 
Создавайте содержательные сообщения об ошибках и передавайте их со своими 
исключениями. Включайте в них сведения о сбойной операции и типе сбоя. 
Если в приложении ведется журнал, передайте информацию, достаточную для регистрации ошибки из секции catch. 

**Определяйте классы исключений в контексте потребностей вызывающей стороны**

Существует много способов классификации ошибок. Например, ошибки можно 
классифицировать по источнику, то есть по компоненту, в котором они произошли. Также возможна классификация по типу: сбои устройств, сетевые сбои, ошибки программирования и т. д. Однако при определении классов исключений в приложениях думать необходимо прежде всего о том, как они будут перехватываться. 

... инкапсуляция вызовов сторонних API принадлежит к числу стандартных приемов. Создавая обертку для стороннего вызова, вы сокращаете до минимума зависимость от него в своем коде: в будущем вы можете переключиться на другую библиотеку без сколько-нибудь заметных проблем. Обертки также упрощают имитацию сторонних вызовов в ходе тестирования кода. 

Часто в определенной области кода бывает достаточно одного класса исключения. 
Информация, передаваемая с исключением, позволяет различать разные виды 
ошибок. Используйте разные классы исключений только в том случае, если вы 
намерены перехватывать одни исключения, разрешая прохождение других типов. 

**Определите нормальный путь выполнения**

Такое решение представляет собой реализацию паттерна ОСОБЫЙ СЛУЧАЙ 
[Fowler]. Программист создает класс или настраивает объект так, чтобы он обрабатывал особый случай за него. Это позволяет избежать обработки исключительного поведения в клиентском коде. Все необходимое поведение инкапсулируется в объекте особого случая. 

**Не возвращайте null**

Возвращая null, мы фактически создаем для себя лишнюю работу, а для вызывающей стороны — лишние проблемы. Стоит пропустить всего одну проверку null, и приложение «уходит в штопор».

Если у вас возникает желание вернуть null из метода, рассмотрите возможность выдачи исключения или возвращения объекта «особого случая». Если ваш код вызывает метод стороннего API, способный вернуть null, создайте для него обертку в виде метода, который инициирует исключение или возвращает объект особого случая. 

**Не передавайте null**

Возвращать null из методов плохо, но передавать null при вызове еще хуже. 

В большинстве языков программирования не существует хорошего способа 
справиться со случайной передачей null с вызывающей стороны. А раз так, разумно запретить передачу null по-умолчанию. В этом случае вы будете знать, что присутствие null в списке аргументов свидетельствует о возникшей проблеме; это будет способствовать уменьшению количества ошибок, сделанных по 
неосторожности. 

**Заключение** 
Чистый код хорошо читается, но он также должен быть надежным. Эти цели не конфликтуют друг с другом. Чтобы написать надежный и чистый код, следует рассматривать обработку ошибок как отдельную задачу, решаемую независимо от основной логики программы. В зависимости от того, насколько нам это удастся, мы сможем прорабатывать ее реализацию независимо от основной логики программы, а это окажет существенное положительное влияние на удобство сопровождения нашего кода. 

## Глава 8. Границы

Редко когда весь программный код наших систем находится под нашим полным 
контролем. 

... этот внешний код мы должны каким-то образом четко интегрировать со своим кодом. В этой главе рассматриваются приемы и методы «сохранения чистоты» границ нашего программного кода. 

**Использование стороннего кода**

Если вы используете граничный интерфейс вроде Map, держите его внутри класса (или тесно связанного семейства классов), в которых он используется. Избегайте его возвращения или передачи в аргументах при вызовах методов общедоступных API. 

**Исследование и анализ границ**

Изучение чужого кода - непростая задача. Интеграция чужого кода тоже сложна. 
Одновременное решение обоих задач создает двойные сложности. А что, если 
пойти по другому пути? Вместо того чтобы экспериментировать и опробовать 
новую библиотеку в коде продукта, можно написать тесты, проверяющие наше 
понимание стороннего кода. Джим Ньюкирк (Jim Newkirk) называет такие тесты 
«учебными тестами» 

В учебных тестах мы вызываем методы стороннего API в том виде, в котором 
намереваемся использовать их в своем приложении. Фактически выполняется 
контролируемый эксперимент, проверяющий наше понимание стороннего API. 
Основное внимание в тестах направлено на то, чего мы хотим добиться при  
помощи API. 

*Учебные тесты: выгоднее, чем бесплатно*

Учебные тесты не стоят ничего. API все равно приходится изучать, а написание 
тестов является простым способом получения необходимой информации, в  
изоляции от рабочего кода. 

Учебные тесты не просто бесплатны - они приносят дополнительную прибыль. 
При выходе новых версий сторонних пакетов вы сможете провести учебные тесты 
и выяснить, не изменилось ли поведение пакета. 

Учебные тесты позволяют убедиться в том, что сторонние пакеты, используемые в коде, работают именно так, как мы ожидаем. 

Впрочем, независимо от того, нужна ли вам учебная информация, получаемая 
в ходе тестирования, в системе должна существовать четкая граница, которая поддерживается группой исходящих тестов, использующих интерфейс по аналогии 
с кодом продукта. Без граничных тестов, упрощающих процесс миграции, у нас 
появляются причины задержаться на старой версии дольше необходимого.

*Использование несуществующего кода*

В коде часто встречаются места, в которых мы не располагаем полной информацией. Иногда то, что находится на другой стороне границы, остается неизвестным (по крайней мере в данный момент). Иногда мы намеренно не желаем заглядывать дальше границы. 

Чтобы не останавливать работу, мы определили собственный интерфейс с броским именем Transmitter. Интерфейс содержал метод transmit, которому при вызове передавались частота и поток данных. Это был тот интерфейс, который нам хотелось бы иметь. 

После того как другая группа определила API передатчика, мы написали класс Transmi tterAdapter для «наведения мостов». АДАПТЕР1 инкапсулировал взаимодействие с API и создавал единое место для внесения изменений в случае развития API. 

**Чистые границы**

... В хорошей программной архитектуре внесение изменений обходится без значительных затрат и усилий по переработке. 

... Для граничного кода необходимо четкое разделение сторон и тесты, определяющие ожидания пользователя. Постарайтесь, чтобы ваш код поменьше знал о специфических подробностях реализации стороннего кода. Лучше зависеть от того, что находится под вашим контролем, чем от тех факторов, которые вы не контролируете (а то, чего доброго, они начнут контролировать вас). 

Чтобы границы со сторонним кодом не создавали проблем в наших проектах, 
мы сводим к минимуму количество обращений к ним. Для этого можно воспользоваться обертками, как в примере с Map, или реализовать паттерн АДАПТЕР 
для согласования нашего идеального интерфейса с реальным, полученным от 
разработчиков. В обоих вариантах код становится более выразительным, обеспечивается внутренняя согласованность обращений через границы, а изменение 
стороннего кода требует меньших затрат на сопровождение. 

## Глава 9. Модульные тесты

Движения гибких методологий и TDD поощряют многих программистов писать автоматизированные модульные тесты... Однако в лихорадочном стремлении интегрировать тестирование в свою работу многие программисты упускают более тонкие и важные аспекты написания хороших тестов. 

**Три закона TTD**

..по требованиям методологии TDD модульные тесты должны писаться заранее, еще до написания кода продукта. Но это правило — всего лишь верхушка айсберга. Рассмотрим следующие три закона:

*Первый закон.* Не пишите код продукта, пока не напишете отказной модульный 
тест. 
*Второй закон.* Не пишите модульный тест в объеме большем, чем необходимо 
для отказа. Невозможность компиляции является отказом. 
*Третий закон.* Не пишите код продукта в объем большем, чем необходимо для 
прохождения текущего отказного теста. 

Эти три закона устанавливают рамки рабочего цикла, длительность которого 
составляет, вероятно, около 30 секунд. Тесты и код продукта пишутся вместе, 
а тесты на несколько секунд опережают код продукта. 

При такой организации работы мы пишем десятки тестов ежедневно, сотни тестов ежемесячно, тысячи тестов ежегодно. Громадный объем тестов может создать немало организационных проблем. 

**О чистоте тестов**

.. тесты «на скорую руку» равносильны полному отсутствию тестов, если не хуже. Дело в том, что тесты должны изменяться по мере развития кода продукта. Чем примитивнее тесты, тем труднее их изменять. Если тестовый код сильно запутан, то может оказаться, что написание нового кода продукта займет меньше времени, чем попытки втиснуть новые тесты в обновленный пакет. При изменении кода продукта старые тесты перестают проходить, а неразбериха в тестовом коде не позволяет быстро разобраться с возникшими проблемами. Tаким образом, тесты начинают рассматриваться как постоянно растущий балласт. 

Однако без тестов программисты лишились возможности убедиться в том, что 
изменения в кодовой базе работают так, как ожидалось. Без тестов они уже не 
могли удостовериться в том, что изменения в одной части системы не нарушают 
работу других частей. Количество ошибок стало возрастать. А с ростом количества непредвиденных дефектов программисты начали опасаться изменений. Они перестали чистить код продукта, потому что боялись: не будет ли от изменений 
больше вреда, чем пользы? Код продукта стал загнивать. В итоге группа осталась 
без тестов, с запутанной и кишащей ошибками кодовой базой, с недовольными 
клиентами и с чувством, что все усилия по тестированию не принесли никакой 
пользы.

Мораль проста: тестовый код не менее важен, чем код продукта. Не считайте его 
«кодом второго сорта». К написанию тестового кода следует относиться вдумчиво, внимательно и ответственно. Тестовый код должен быть таким же чистым, как и код продукта.

**Тесты как средство обеспечения изменений**

Если не поддерживать чистоту своих тестов, то вы их лишитесь. А без тестов 
утрачивается все то, что обеспечивает гибкость кода продукта. Да, вы не ошиблись. Именно модульные тесты обеспечивают гибкость, удобство сопровождения 
и возможность повторного использования нашего кода. Это объясняется просто: 
если у вас есть тесты, вы не боитесь вносить изменения в код! Без тестов любое 
изменение становится потенциальной ошибкой. Какой бы гибкой ни была ваша 
архитектура, каким бы качественным ни было логическое деление вашей архитектуры, без тестов вы будете сопротивляться изменениям из опасений, что они 
приведут к появлению скрытых ошибок. 

С тестами эти опасения практически полностью исчезают. Чем шире охват 
тестирования, тем меньше вам приходится опасаться. Вы можете практически 
свободно вносить изменения даже в имеющий далеко не идеальную архитектуру, 
запутанный и малопонятный код. Таким образом, вы можете спокойно улучшать 
архитектуру и строение кода! 

Таким образом, если ваши тесты недостаточно чисты и проработаны, ваши  
возможности по изменению кода сокращаются и вы лишаетесь возможности  
улучшения структуры кода. Некачественные тесты приводит к некачественному коду 
продукта. В конечном итоге тестирование вообще становятся невозможным, и код 
продукта начинает загнивать. 

**Чистые тесты**

...удобочитаемость в модульных тестах играет еще более важную роль, чем в коде продукта. 
Что делает тестовый код удобочитаемым? То же, что делает удобочитаемым 
любой другой код: ясность, простота и выразительность. В тестовом коде необходимо передать максимум информации минимумом выразительных средств. 

**Предметно-ориентированный язык тестирования**

...Вместо вызова функций API, используемых программистами для манипуляций с системой, мы строим набор функций и служебных программ, использующих API; это упрощает написание и чтение тестов. Наши функции и служебные программы образуют специализированный API, то есть по сути — язык тестирования, который программисты используют для упрощения работы над тестами, а также чтобы помочь другим программистам, которые будут читать эти тесты позднее. 

Тестовый API не проектируется заранее; он развивается на базе многократной 
переработки тестового кода, перегруженного ненужными подробностями. ...дисциплинированные разработчики перерабатывают свой тестовый код в более лаконичные и выразительные формы. 

**Двойной стандарт**

тестовый код работает в тестовой среде, а не в среде реальной эксплуатации продукта, а эти среды весьма заметно различаются по своим потребностям. 

... Многое из того, что вы никогда не станете делать в среде эксплуатации продукта, абсолютно нормально выглядит в среде тестирования. Обычно речь идет о затратах памяти или эффективности работы процессора — но никогда о проблемах чистоты кода.

**Одна проверка на тест**

Существует точка зрения, согласно которой каждая тестовая функция в тесте 
JUnit должна содержать одну — и только одну — директиву assert. Такое правило может показаться излишне жестким, но его преимущества наглядно видны. Тесты приводят к одному выводу, который можно быстро и легко понять при чтении. 

К сожалению, такое разбиение приводит к появлению большого количества дублирующегося кода.

Чтобы избежать дублирования, можно воспользоваться паттерном  
ШАБЛОННЫЙ МЕТОД [GOF], включить части given/when в базовый класс, а части then — в различные производные классы. А можно создать отдельный тестовый класс, поместить части given и when в функцию @Before, а части then — в каждую  
функцию @Test. Но похоже, такой механизм слишком сложен для столь  
незначительной проблемы. В конечном итоге я предпочел решение с множественным директивами assert. 
...правило «одного assert» является хорошей рекомендацией. Обычно 
я стараюсь создать предметно-ориентированный язык тестирования, который 
это правило поддерживает, как в листинге 9.5. Но при этом я не боюсь включать 
в свои тесты более одной директивы assert. Вероятно, лучше всего сказать, что 
количество директив assert в тесте должно быть сведено к минимуму. 

**Одна концепция на тест**

Пожалуй, более полезное правило гласит, что в каждой тестовой функции должна 
тестироваться одна концепция. Мы не хотим, чтобы длинные тестовые функции 
выполняли несколько разнородных проверок одну за другой. ... Объединение их в одной функции заставляет читателя гадать, почему в функцию включается каждая секция, и какое условие проверяется в этой секции. 

Проблема в том, что тест проверяет более одной концепции. Так что, вероятно, лучше всего сформулировать это правило так: количество директив assert на концепцию должно быть минимальным, и в тестовой функции должна проверяться только одна концепция.

**F.I.R.S.T.**

Чистые тесты должны обладать еще пятью характеристиками, названия которых 
образуют приведенное сокращение. 
*Быстрота (Fast).* Тесты должны выполняться быстро. Если тесты выполняются 
медленно, вам не захочется часто запускать их. Без частого запуска тестов  
проблемы не будут выявляться на достаточно ранней стадии, когда они особенно 
легко исправляются. В итоге вы уже не так спокойно относитесь к чистке своего 
кода, и со временем код начинает загнивать. 
*Независимость (Independent).* Тесты не должны зависеть друг от друга. Один 
тест не должен создавать условия для выполнения следующего теста. Все тесты 
должны выполняться независимо и в любом порядке на ваше усмотрение. Если 
тесты зависят друг от друга, то при первом отказе возникает целый каскад сбоев, 
который усложняет диагностику и скрывает дефекты в зависимых тестах. 
*Повторяемость (Repeatable).* Тесты должны давать повторяемые результаты 
в любой среде. Вы должны иметь возможность выполнить тесты в среде реальной 
эксплуатации, в среде тестирования или на вашем ноутбуке во время  
возвращения домой с работы. Если ваши тесты не будут давать однозначных результатов 
в любых условиях, вы всегда сможете найти отговорку для объяснения неудач. 
Также вы лишитесь возможности проводить тестирование, если нужная среда 
недоступна. 
*Очевидность (Self-Validating).* Результатом выполнения теста должен быть  
логический признак. Тест либо прошел, либо не прошел. Чтобы узнать результат, 
пользователь не должен читать журнальный файл. Не заставляйте его вручную 
сравнивать два разных текстовых файла. Если результат теста не очевиден, то 
отказы приобретают субъективный характер, а выполнение тестов может  
потребовать долгой ручной обработки данных. 
*Своевременность (Timely).* Тесты должны создаваться своевременно.  
Модульные тесты пишутся непосредственно перед кодом продукта, обеспечивающим их прохождение. Если вы пишете тесты после кода продукта, вы можете решить, что 
тестирование кода продукта создает слишком много трудностей, а все из-за того, 
что удобство тестирования не учитывалось при проектировании кода продукта. 

**Заключение**

Для «здоровья» проекта тесты не 
менее важны, чем код продукта. А может быть, они еще важнее, потому что  
тесты сохраняют и улучшают гибкость, удобство сопровождения и возможности 
повторного использования кода продукта. Постоянно следите за чистотой своих 
тестов. Постарайтесь сделать их выразительными и лаконичными. Изобретайте 
тестовые API, которым отводится роль предметно-ориентированного языка  
тестирования, упрощающего написание тестов. 
Если вы будете пренебрежительно относиться к тестам, то и ваш код начнет  
загнивать. Поддерживайте чистоту в своих тестах.

## Глава 10. Классы

**Строение класса**

По стандартным правилам Java класс должен начинаться со списка переменных. 
Сначала перечисляются открытые статические константы. Далее следуют приватные статические переменные, а за ними идут приватные переменные экземпляров. Открытых переменных обычно нет, трудно найти веские причины для их использования. 
За списком переменных обычно следуют открытые функции. Мы предпочитаем размещать приватные вспомогательные функции, вызываемые открытыми 
функциями, непосредственно за самой открытой функцией. Такое размещение 
соответствует правилу понижения, в результате чего программа читается как 
газетная статья.

**Инкапсуляция**

Мы предпочитаем объявлять переменные и вспомогательные функции  
приватными, но относимся к ним без фанатизма. Иногда переменную или  
вспомогательную функцию приходится объявлять защищенной, чтобы иметь возможность обратиться к ней из теста. С нашей точки зрения тесты исключительно важны. Если тест из того же пакета должен вызвать функцию или обратиться к  
переменной, мы используем защищенный или пакетный уровень доступа. Тем не менее начинать следует с поиска способа, сохраняющего приватность. Ослабление 
инкапсуляции всегда должно быть последней мерой. 

**Классы должны быть компактными!**

...как и в случае с функциями, компактность должна стать основным правилом проектирования классов. 

Размер функций определяется количеством физических строк. В классах используется другая метрика; мы подсчитываем ответственности [RDD]. 

Имя класса должно описывать его ответственности. В сущности, имя должно 
стать первым фактором, способствующим определению размера класса. Если 
для класса не удается подобрать четкое, короткое имя, вероятно, он слишком 
велик. Чем туманнее имя класса, тем больше вероятность, что он имеет  
слишком много ответственностей. В частности, присутствие в именах классов слов- 
проныр «Processor», «Manager» и «Super» часто свидетельствует о нежелательном 
объединении ответственностей. 

Краткое описание класса должно укладываться примерно в 25 слов, без выражений «если», «и», «или» и «но». 

**Принцип единой ответственности (SRP)**

Принцип единой ответственности (SRP1) утверждает, что класс или модуль 
должен иметь одну — и только одну — причину для изменения. Этот принцип 
дает нам как определение ответственности, так и критерий для оценки размера 
класса. Классы должны иметь одну ответственность, то есть одну причину для 
изменений. 

Принцип единой ответственности — одна из самых важных концепций 
в объектно-ориентированном проектировании. Кроме того, его относительно 
несложно понять и соблюдать. Но как ни странно, принцип единой ответственности часто оказывается самым нарушаемым принципом проектирования классов. Мы постоянно встречаем классы, которые делают слишком много всего. 
Почему? 
Заставить программу работать и написать чистый код — совершенно разные 
вещи. Обычно мы думаем прежде всего о том, чтобы наш код заработал, а не 
о его структуре и чистоте. И это абсолютно законно. Разделение ответственности 
в работе программиста играет не менее важную роль, чем в наших программах. 

... система с множеством малых классов имеет не больше «подвижных частей», чем система с несколькими большими классами. В последней тоже придется разбираться, и это будет ничуть не проще. Так что вопрос заключается в следующем: хотите ли вы, чтобы ваши инструменты были разложены по ящикам с множеством небольших отделений, содержащих четко определенные и подписанные компоненты? Или вы предпочитаете несколько больших ящиков, в которые можно сваливать все подряд? 

Еще раз выделю основные моменты: система должна состоять из множества  
мелких классов, а не из небольшого числа больших. Каждый класс инкапсулирует 
одну ответственность, имеет одну причину для изменения и взаимодействует 
с другими классами для реализации желаемого поведения системы. 

**Связность**

Классы должны иметь небольшое количество переменных экземпляров. Каждый 
метод класса должен оперировать с одной или несколькими из этих переменных. 
В общем случае, чем с большим количеством переменных работает метод, тем 
выше связность этого метода со своим классом. Класс, в котором каждая  
переменная используется каждым методом, обладает максимальной связностью. 
Как правило, создавать классы с максимальной связностью не рекомендуется... 
а скорее всего, это нереально. С другой стороны, связность класса должна быть 
высокой. Высокая связность означает, что методы и переменные класса  
взаимозависимы и существуют как единое целое. 

Стратегия компактных функций и коротких списков параметров иногда  
приводит к росту переменных экземпляров, используемых подмножеством методов. 
Это почти всегда свидетельствует о том, что по крайней мере один класс  
пытается выделиться из более крупного класса. Постарайтесь разделить переменные 
и методы на два и более класса, чтобы новые классы обладали более высокой 
связностью. 

**Поддержание связности приводит к уменьшению классов**

... Если классы утрачивают связность, разбейте их!

Таким образом, разбиение большой функции на много мелких функций также 
часто открывает возможность для выделения нескольких меньших классов. 

**Структурирование с учетом изменений**

Большинство систем находится в процессе непрерывных изменений. Каждое  
изменение создает риск того, что остальные части системы будут работать не так, 
как мы ожидаем. В чистой системе классы организованы таким образом, чтобы 
риск от изменений был сведен к минимуму. 

... открытие класса создает риск. Любые изменения в этом классе создают потенциальную возможность для нарушения работы остального кода класса, поэтому весь код приходится полностью тестировать заново. 

... Приватные методы, действие которых распространяется только на небольшое 
подмножество класса, — хороший признак для поиска потенциальных  
усовершенствований. ...

... Код каждого класса становится до смешного простым. Время, необходимое для 
понимания класса, падает почти до нуля. Вероятность того, что одна из функций 
нарушит работу другой, ничтожно мала. С точки зрения тестирования проверка 
всех фрагментов логики в этом решении упрощается, поскольку все классы  
изолированы друг от друга. ...

... Структура системы должна быть такой, чтобы обновление системы (с  
добавлением новых или изменением существующих аспектов) создавало как можно 
меньше проблем. В идеале новая функциональность должна реализовываться 
расширением системы, а не внесением изменений в существующий код. 

**Изоляция изменений**

Потребности меняются со временем; следовательно, меняется и код. В начальном 
курсе объектно-ориентированного программирования мы узнали, что классы 
делятся на конкретные, содержащие подробности реализации (код), и  
абстрактные, представляющие только концепции. Если клиентский класс зависит от 
конкретных подробностей, то изменение этих подробностей может нарушить его 
работоспособность. Чтобы изолировать воздействие этих подробностей на класс, 
в систему вводятся интерфейсы и абстрактные классы. 

Зависимости от конкретики создает проблемы при тестировании системы. ...

... Если система обладает достаточной логической изоляцией для подобного  
тестирования, она также становится более гибкой и более подходящей для повторного 
использования. Отсутствие жестких привязок означает, что элементы системы 
лучше изолируются друг от друга и от изменений. Изоляция упрощает  
понимание каждого элемента системы. 
Сведение к минимуму логических привязок соответствует другому принципу 
проектирования классов, известному как принцип обращения зависимостей (DIP, 
Dependency Inversion Principle). По сути DIP гласит, что классы системы должны 
зависеть от абстракций, а не от конкретных подробностей.

## Глава 11. Системы

**Отделение конструирования системы от ее использования**

В программных системах фаза инициализации, в которой конструируются  
объекты приложения и «склеиваются» основные зависимости, тоже должна отделяться 
от логики времени выполнения, получающей управление после ее завершения. 
Фаза инициализации присутствует в каждом приложении. Это первая из областей 
ответственности (concerns), которую мы рассмотрим в этой главе, а сама  
концепция разделения ответственности относится к числу самых старых и важных 
приемов нашего ремесла. 

...

Идиома ОТЛОЖЕННОЙ ИНИЦИАЛИЗАЦИИ обладает определенными 
достоинствами. Приложение не тратит времени на конструирование объекта 
до момента его фактического использования, а это может ускорить процесс 
инициализации. Кроме того, мы следим за тем, чтобы функция никогда не  
возвращала null. 
Однако в программе появляется жестко закодированная зависимость от класса 
MyServicelmpl и всего, что необходимо для его конструктора (который я не  
привел). Программа не компилируется без разрешения этих зависимостей, даже если 
объект этого типа ни разу не используется во время выполнения! 
Проблемы могут возникнуть и при тестировании. ...

... Если вы действительно стремитесь к созданию хорошо структурированных, 
надежных систем, никогда не допускайте, чтобы удобные идиомы вели к  
нарушению модульности. Процесс конструирования объектов и установления связей 
не является исключением. Этот процесс должен быть отделен от нормальной 
логики времени выполнения, а вы должны позаботиться о выработке глобальной, 
последовательной стратегии разрешения основных зависимостей. 

**Отделение main**

Один из способов отделения конструирования от использования заключается 
в простом перемещении всех аспектов конструирования в main (или модули, 
вызываемые из main). Далее весь остальной код системы пишется в предположении, что все объекты были успешно сконструированы и правильно связаны друг с другом...

Функция main строит объекты, необходимые для системы, а затем передает их  
приложению, которое их просто использует. Обратите внимание на направление стрелок зависимостей, пересекающих границу между main и приложением. Все стрелки указывают в одном направлении — от main. Это означает, что приложение  
ничего не знает о mai п или о процессе конструирования. Оно просто ожидает, что все 
объекты были построены правильно. 

**Фабрики**

Конечно, в некоторых ситуациях момент создания объекта должен  
определяться приложением. Например, в системе обработки заказов приложение должно создать экземпляры товаров Lineltem для включения их в объект заказа Order. 
В этом случае можно воспользоваться паттерном АБСТРАКТНАЯ ФАБРИКА 
[GOF], чтобы приложение могло само выбрать момент для создания Lineltem, 
но при этом подробности конструирования были отделены от кода приложения 

**Внедрение зависимостей**

Внедрение зависимостей (DI, Dependency Injection) — мощный механизм  
отделения конструирования от использования, практическое применение обращения 
контроля (IoC, Inversion of Control) в области управления зависимостями1.  
Обращение контроля перемещает вторичные обязанности объекта в другие объекты, 
созданные специально для этой цели, тем самым способствуя соблюдению  
принципа единой ответственности. В контексте управления зависимостями объект не 
должен брать на себя ответственность за создание экземпляров зависимостей. 
Вместо этого он передает эту обязанность другому «уполномоченному»  
механизму Так как инициализация является глобальной областью ответственности, 
этим уполномоченным механизмом обычно является либо функция main, либо 
специализированный контейнер. 

Примером «частичной» реализации внедрения зависимостей является запрос 
JNDI, когда объект обращается к серверу каталоговой информации с запросом 
на предоставление «сервиса» с заданным именем...

Истинное внедрение зависимостей идет еще на один шаг вперед. Класс не  
предпринимает непосредственных действий по разрешению своих зависимостей; 
он остается абсолютно пассивным. Вместо этого он предоставляет set-методы 
и/или аргументы конструктора, используемые для внедрения зависимостей. 
В процессе конструирования контейнер DI создает экземпляры необходимых 
объектов (обычно по требованию) и использует аргументы конструктора или 
set-методы для скрепления зависимостей. Фактически используемые  
зависимые объекты задаются в конфигурационном файле или на программном уровне в специализированном конструирующем модуле. 

**Масштабирование**

Возможность построить «правильную систему с первого раза» — миф. Вместо 
этого мы сегодня реализуем текущие потребности, а завтра перерабатываем 
и расширяем систему для реализации новых потребностей. В этом заключается 
суть итеративной, пошаговой гибкой разработки. Разработка через тестирование, 
рефакторинг и полученный в результате их применения чистый код  
обеспечивают работу этой схемы на уровне кода. 

*В этом проявляется важнейшее отличие программных систем от физических.  
Архитектура программных систем может развиваться последовательно, если  
обеспечить правильное разделение ответственности.*

... В EJB2 компоненты часто определяют «объекты передачи данных» (DTO), которые фактически представляют собой «структуры без поведения». Обычно это приводит к появлению избыточных типов, содержащих по сути одинаковые данные, и необходимости использования стереотипного кода для копирования данных между объектами. 

**Поперечные области ответственности**

Такие области, как сохранение объектов, выходят за рамки естественных границ 
объектов предметной области. Например, все объекты обычно сохраняются по 
одной стратегии, с использованием определенной СУБД1 вместо  
неструктурированных файлов, с определенной схемой выбора имен таблиц и столбцов, единой транзакционной семантикой и т. д. 
Теоретически возможен модульный, инкапсулированный подход к определению 
стратегии сохранения объектов. Однако на практике вам приходится повторять 
по сути одинаковый код, реализующий стратегию сохранения, во многих  
объектах. Для подобных областей используется термин *«поперечные области 
ответственности»*. При этом инфраструктура сохранения может быть модульной, 
и логика предметной области, рассматриваемая в изоляции, тоже может быть  
модульной. Проблемы возникают в точках пересечения этих областей. Можно  
сказать, что подход, использованный в архитектуре EJB по отношению к сохранению 
объектов, безопасности и транзакциям, предвосхитил аспектно-ориентированное 
программирование (АОП2), которое представляет собой универсальный подход 
к восстановлению модульности для поперечных областей ответственности. 

В АОП специальные модульные конструкции, называемые аспектами,  
определяют, в каких точках системы поведение должно меняться некоторым  
последовательным образом в соответствии с потребностями определенной области 
ответственности. Определение осуществляется на уровне декларативного или 
программного механизма. 
В примере с сохранением объектов вы объявляете, какие объекты, атрибуты и т. д. 
должны сохраняться, а затем делегируете задачи сохранения своей инфраструктуре сохранения. Изменения в поведении вносятся инфраструктурой АОП без вмешательства в целевой код. Рассмотрим три аспекта (или «аспекто-подобных» 
механизма) в Java. 

**Посредники (proxies)**

Посредники (proxies) хорошо подходят для простых ситуаций — например, для 
создания «оберток» для вызова методов отдельных объектов или классов. Тем 
не менее динамические посредники, содержащиеся в JDK, работают только 
с интерфейсами. Чтобы создать посредника для класса, приходится использовать 
библиотеки для выполнения манипуляций с байт-кодом — такие, как CGLIB, 
ASM или Javassist.

... Объем и сложность кода — два основных недостатка 
посредников. Эти два фактора усложняют создание чистого кода! Кроме того, 
у посредников не существует механизма определения «точек интереса»  
общесистемного уровня, необходимых для полноценного АОП-решения.

**АОП-инфраструктуры на «чистом» Java**

К счастью, большая часть шаблонного кода посредников может автоматически 
обрабатываться вспомогательными средствами. Посредники используются во 
внутренней реализации нескольких инфраструктур Java — например, Spring 
АОР и JBoss АОР — для реализации аспектов непосредственно на уровне Java3. 
В Spring бизнес-логика записывается в форме POJO-объектов. Такие объекты 
полностью сосредоточены на своей предметной области. Они не имеют  
зависимостей во внешних инфраструктурах (или любых других областях);  
соответственно им присуща большая концептуальная простота и удобство тестирования. 
Благодаря относительной простоте вам будет проще обеспечить правильную 
реализацию соответствующих пожеланий пользователей, а также сопровождение 
и эволюцию кода при появлении новых пожеланий. 
Вся необходимая инфраструктура приложения, включая поперечные области 
ответственности (сохранение объектов, транзакции, безопасность, кэширование, 
преодоление отказов и т. д.), определяется при помощи декларативных  
конфигурационных файлов или API. Во многих случаях вы фактически определяете 
аспекты библиотек Spring или JBoss, а инфраструктура берет на себя всю  
механику использования посредников Java или библиотек байт-кода в режиме, 
прозрачном для пользователя. Объявления управляют контейнером внедрения 
зависимостей (DI), который создает экземпляры основных объектов и связывает 
их по мере необходимости. 

**Аспекты AspectJ**

Наконец, самым полнофункциональным инструментом для разделения областей 
ответственности посредством использования аспектов является язык AspectJ1 — 
расширение Java, предоставляющее «полноценную» поддержку аспектов как 
модульных конструкций. Чистых Java-решений на базе Spring и JBoss достаточно 
для 80-90% ситуаций, в которых применяются аспекты. Тем не менее AspectJ 
предоставляет очень мощный и разносторонний инструментарий для реализации разделения ответственности. Недостатком AspectJ является необходимость освоения нескольких новых инструментов, а также изучения новых языковых конструкций и идиом. 
Эти проблемы отчасти компенсируются появившейся недавно «аннотационной» 
формой AspectJ, в которой аннотации Java 5 используются для определения 
аспектов в «чистом» коде Java. Кроме того, Spring Framework также содержит 
ряд функций, существенно упрощающих внедрение аспектов на базе аннотаций 
в рабочих группах с ограниченным опытом применения AspectJ. 

**Испытание системной архитектуры**

Трудно переоценить потенциал разделения ответственности посредством аспект - 
ных решений. Если вы можете написать логику предметной области своего  
приложения в виде POJO-объектов, отделенных от любых архитектурных областей 
ответственности на кодовом уровне, то перед вами открывается возможность 
проведения полноценных испытаний вашей архитектуры. Вы сможете развивать 
ее от простого к сложному, как потребует ситуация, подбирая новые технологии 
по мере надобности. Не обязательно создавать Большой Изначальный Проект 
(BDUF, Big Design Up Front)1. Более того, это даже вредно, потому что BDUF 
снижает возможность адаптации к изменениям из-за нашего психологического 
нежелания расставаться с результатами уже затраченных усилий; кроме того, 
изначально принятые решения влияют на наши последующие представления об 
архитектуре. 

*Оптимальная архитектура системы состоит из модульных областей  
ответственности, каждая из которых реализуется на базе POJO-объектов. Области  
интегрируются между собой при помощи аспектов или аналогичных средств, минимальным образом вмешивающихся в их работу. Такая архитектура может строиться на базе методологии разработки через тестирование, как и программный код.*

**Оптимизация принятия решений**

Модульность и разделение ответственности позволяют децентрализовать  
управление и принятие решений. ...

... Гибкость POJO-системы с модульными областями ответственности позволяет  
принимать оптимальные, своевременные решения на базе новейшей информации. 
Кроме того, она способствует снижению сложности таких решений. 

**Применяйте стандарты разумно, когда они приносят очевидную пользу**

Стандарты упрощают повторное использование идей и компонентов, привлечение людей с необходимым опытом, воплощение удачных идей и связывание компонентов. Тем не менее, процесс создания стандарта иногда занимает слишком 
много времени (а отрасль не стоит на месте), в результате чего стандарты теряют связь с реальными потребностями тех людей, которым они должны служить. 

**Системам необходимы предметно-ориентированные языки**

Хороший предметно-ориентированный язык сводит к минимуму  
«коммуникационный разрыв» между концепцией предметной области и кодом, реализующим 
эту концепцию — по аналогии с тем, как гибкие методологии оптимизируют 
обмен информацией между группой и ключевыми участниками проекта.  
Реализация логики предметной области на языке, используемом экспертом в этой 
области, снижает риск неверного представления предметной области в коде. 
Предметно-ориентированные языки, когда они используются эффективно,  
поднимают уровень абстракции над программными идиомами и паттернами  
проектирования. Они позволяют разработчику выразить свои намерения на  
соответствующем уровне абстракции. 

*Предметно-ориентированные языки позволяют выразить в форме POJO-объектов 
все уровни абстракции и все предметные области приложения, от  
высокоуровневых политик до низкоуровневых технических подробностей.*

**Заключение**
Чистым должен быть не только код, но и архитектура системы. Агрессивная,  
«всепроникающая» архитектура скрывает логику предметной области и снижает  
гибкость. Первое приводит к снижению качества: ошибкам проще спрятаться в коде, 
а разработчику труднее реализовать пожелания пользователей. Второе  
оборачивается снижением производительности, а также потерей всех преимуществ TDD. 
Намерения разработчика должны быть четко выражены на всех уровнях  
абстракции. Это произойдет только в том случае, если он создает POJO-объекты, 
и использует аспекты (или другие аналогичные механизмы) для неагрессивного 
воплощения других сторон реализации. 
Независимо от того, проектируете ли вы целую систему или ее отдельные модули, 
помните: используйте самое простое решение из всех возможных.

## Глава 12. Формирование архитектуры

Согласно Кенту, архитектура может считаться «простой», если она: 

- обеспечивает прохождение всех тестов

- не содержит дублирующегося кода

- выражает намерения программиста

- использует минимальное количество классов и методов

Правила приведены в порядке их важности.

**Правило № 1: выполнение всех тестов**

...Система, тщательно протестированная и прошедшая все тесты, контролируема

...классы,  соответствующие принципу SRP, проще тестировать. Чем больше тестов мы напишем, тем дальше продвинемся к простоте тестирования. Таким образом, обеспечение полной контролируемости системы помогает повысить качество проектирования.

Жесткая привязка усложняет написание тестов. Таким образом, чем больше 
тестов мы пишем, тем интенсивнее используем такие принципы, как DIP, и  
такие инструменты, как внедрение зависимостей, интерфейсы и абстракции, для 
минимизации привязок. 
Как ни удивительно, выполнение простого и очевидного правила, гласящего, 
что для системы необходимо написать тесты и постоянно выполнять их, влияет 
на соответствие системы важнейшим критериям объектно-ориентированного 
программирования: устранению жестких привязок и повышению связности. 
Написание тестов улучшает архитектуру системы. 

**Правила № 2-4: переработка кода**

Когда у вас появился полный набор тестов, можно заняться чисткой кода и  
классов. Для этого код подвергается последовательной переработке (рефакторингу). 

... Наличие тестов избавляет от опасений, что чистка кода нарушит его работу! 

В фазе переработки применяется абсолютно все, что вы знаете о качественном 
проектировании программных продуктов. В ход идут любые приемы: повышение 
связности, устранение жестких привязок, разделение ответственности, изоляция 
системных областей ответственности, сокращение объема функций и классов, 
выбор более содержательных имен и т. д. Также применяются три критерия 
простой архитектуры: устранение дубликатов, обеспечение выразительности 
и минимизация количества классов и методов. 

***Отсутствие дублирования***

Дублирование — главный враг хорошо спроектированной системы. Его последствия — лишняя работа, лишний риск и лишняя избыточная сложность. 

... дублирование может существовать и в других формах — таких, как дублирование реализации. 

... принцип «повторного использования даже в мелочах» может привести к значительному сокращению сложности системы. 

***Выразительность***

Легко написать код, понятный для нас самих, потому что в момент его написания мы глубоко понимаем решаемую проблему. У других программистов, которые будут заниматься сопровождением этого кода, такого понимания не будет. 

Чтобы свести к минимуму риск появления дефектов в ходе внесения 
изменений, очень важно понимать, как работает система. С ростом сложности 
системы разработчику приходится разбираться все дольше и дольше, а  
вероятность того, что он поймет что-то неправильно, только возрастает. Следовательно, 
код должен четко выражать намерения своего автора. Чем понятнее будет код, 
тем меньше времени понадобится другим программистам, чтобы разобраться 
в нем. Это способствует уменьшению количества дефектов и снижению затрат 
на сопровождение. 
Хороший выбор имен помогает выразить ваши намерения. Имя класса или  
функции должно восприниматься «на слух», а когда читатель разбирается в том, что 
делает класс, это не должно вызывать у него удивления. 
Относительно небольшой размер функций и классов также помогает выразить 
ваши намерения. Компактным классам и функциям проще присваивать имена; 
они легко пишутся и в них легко разобраться.

Стандартная номенклатура также способствует выражению намерений автора. 
В частности, передача информация и выразительность являются важнейшими 
целями для применения паттернов проектирования. Включение стандартных 
названий паттернов (например, КОМАНДА или ПОСЕТИТЕЛЬ) в имена  
классов, реализующих эти паттерны, помогает кратко описать вашу архитектуру для 
других разработчиков. 
Хорошо написанные модульные тесты тоже выразительны. Они могут  
рассматриваться как разновидность документации, построенная на конкретных примерах. Читая код тестов, разработчик должен составить хотя бы общее представление о том, что делает класс. 

И все же самое важное, что можно сделать для создания выразительного кода — 
это постараться сделать его выразительным. ... помните: следующим человеком, 
которому придется разбираться в вашем коде, с большой вероятностью окажетесь 
вы сами. 

***Минимум классов и методов***

Даже такие фундаментальные концепции, как устранение дубликатов,  
выразительность кода и принцип единой ответственности, могут зайти слишком  
далеко. Стремясь уменьшить объем кода наших классов и методов, мы можем  
наплодить слишком много крошечных классов и методов. Это правило рекомендует 
ограничиться небольшим количеством функций и классов. 

Многочисленность классов и методов иногда является результатом  
бессмысленного догматизма. В качестве примера можно привести стандарт кодирования, который требует создания интерфейса для каждого без исключения класса. Или разработчиков, настаивающих, что поля данных и поведение всегда должны быть разделены на классы данных и классы поведения. Избегайте подобных догм, а в своей работе руководствуйтесь более прагматичным подходом. 

Наша цель — сделать так, чтобы система была компактной, но при этом  
одновременно сохранить компактность функций и классов. Однако следует помнить, 
что из четырех правил простой архитектуры это правило обладает наименьшим 
приоритетом. Свести к минимуму количество функций и классов важно,  однако прохождение тестов, устранение дубликатов и выразительность кода все же 
важнее. 

**Заключение**

Может ли набор простых правил заменить практический опыт? Нет, конечно. 
С другой стороны, правила, описанные в этой главе и в книге, представляют  
собой кристаллизованную форму многих десятилетий практического опыта  
авторов. Принципы простой архитектуры помогают разработчикам следовать по 
тому пути, который им пришлось бы самостоятельно прокладывать в течение 
многих лет.

## Глава 17. Запахи и эвристические правила

### Комментарии

**С1: Неуместная информация**

Комментарии должны быть зарезервированы для технической информации о коде и его архитектуре.

**С2: Устаревший комментарий**

Комментарии стареют довольно быстро. Не пишите комментарии, которые 
с течением времени устареют. Обнаружив устаревший комментарий, обновите 
его или избавьтесь от него как можно быстрее. Устаревшие комментарии часто 
«отрываются» от кода, который они когда-то описывали. Так в вашем коде  
появляются плавучие островки недостоверности и бесполезности. 

**СЗ: Избыточный комментарий**

Избыточным считается комментарий, описывающий то, что и так очевидно.  
Например: 
`i++; // Увеличение переменной i `

Или другой пример — комментарий Javadoc, который содержит не больше (а вернее, меньше) полезной информации, чем простая сигнатура функции.

Комментарии должны говорить то, что не может сказать сам код. 

**С4: Плохо написанный комментарий**

Если уж вы беретесь за написание комментария, напишите его хорошо. Не  
жалейте времени и позаботьтесь о том, чтобы это был лучший комментарий, который 
вы способны создать. Тщательно выбирайте слова. Следите за правильностью 
орфографии и пунктуации. Не пишите сумбурно. Не объясняйте очевидное. 
Будьте лаконичны. 

**С5: Закомментированный код**

Этот код только попусту занимает место, «загнивая» и утрачивая актуальность 
с каждым днем. В нем вызываются несуществующие функции. В нем используются переменные, имена которых давно изменились. В нем соблюдаются устаревшие конвенции. Он загрязняет модуль, в котором он содержится, и отвлекает людей, которые пытаются его читать. Закомментированный код отвратителен!
Увидев закомментированный код, удалите его! Не беспокойтесь, система управления исходным кодом его не забудет. 

### Рабочая среда

**Е1: Построение состоит из нескольких этапов**

Построение проекта должно быть одной тривиальной операцией. ...

... Сначала вы проверяете систему одной простой командой, а потом вводите другую простую команду для ее построения.

**E2: Тестирование состоит из нескольких этапов**

Все модульные тесты должны выполняться всего одной командой. В лучшем 
случае все тесты запускаются одной кнопкой в IDE. В худшем случае одна простая команда вводится в командной строке. Запуск всех тестов — настолько важная и фундаментальная операция, что она должна быть быстрой, простой и очевидной. 

### Функции

**F1: Слишком много аргументов**

Лучше всего, когда аргументов вообще нет; далее следуют функции с одним, двумя и тремя  аргументами. Функции с четырьмя и более аргументами весьма сомнительны; 
старайтесь не использовать их в своих программах.

**F2: Выходные аргументы**

Выходные аргументы противоестественны. Читатель кода ожидает, что аргументы используются для передачи входной, а не выходной информации. Если ваша функция должна изменять чье-либо состояние, пусть она изменяет состояние объекта, для которого она вызывалась.

**F3: Флаги в аргументах**
Логические аргументы явно указывают на то, что функция выполняет более 
одной операции. Они сильно запутывают код. Исключите их из своих программ

**F4: Мертвые функции**
Если метод ни разу не вызывается в программе, то его следует удалить. Хранить 
«мертвый код» расточительно. Не бойтесь удалять мертвые функции. Не забудьте, что система управления исходным кодом позволит восстановить их в случае необходимости. 

### Разное

**G1: Несколько языков в одном исходном файле**

Современные среды программирования позволяют объединять в одном исходном 
файле код, написанный на разных языках. Например, исходный файл на языке 
Java может содержать вставки XML, HTML, YAML, JavaDoc, English, JavaScript 
и т. д. ...

...В лучшем случае результат получается запутанным, а в худшем — неаккуратным и ненадежным. 

В идеале исходный файл должен содержать код на одном — и только одном! — 
языке. На практике без смешения языков обойтись, скорее всего, не удастся. Но 
по крайней мере следует свести к минимуму как количество, так и объем кода на 
дополнительных языках в исходных файлах. 

**G2: Очевидное поведение не реализовано** 

Согласно «принципу наименьшего удивления», любая функция или класс 
должны реализовать то поведение, которого от них вправе ожидать программист. ...

... Если очевидное поведение не реализовано, читатели и пользователи кода  
перестают полагаться на свою интуицию в отношении имен функций. Они теряют 
доверие к автору кода и им приходится разбираться во всех подробностях  
реализации. 

**G3: Некорректное граничное поведение**

Код должен работать правильно — вроде бы очевидное утверждение. Беда в том, 
что мы редко понимаем, насколько сложным бывает правильное поведение.  
Разработчики часто пишут функции, которые в их представлении работают, а затем 
доверяются своей интуиции вместо того, чтобы тщательно проверить  
работоспособность своего кода во всех граничных и особых ситуациях. 
Усердие и терпение ничем не заменить. Каждая граничная ситуация, каждый 
необычный и особый случай способны нарушить работу элегантного и  
интуитивного алгоритма. Не полагайтесь на свою интуицию. Найдите каждое граничное условие и напишите для него тест. 

**G4: Отключенные средства безопасности**

Отключать средства безопасности рискованно. Ручное управление serialVersion- 
UID бывает необходимо, но оно всегда сопряжено с риском. Иногда отключение 
некоторых (или всех!) предупреждений компилятора позволяет успешно  
построить программу, но при этом вы рискуете бесконечными отладочными  
сеансами. Не отключайте сбойные тесты, обещая себе, что вы заставите их проходить 
позднее, — это так же неразумно, как считать кредитную карту источником  
бесплатных денег. 

**G5: Дублирование**

Это одно из самых важных правил в книге и к нему следует относиться очень 
серьезно. Практически каждый автор, пишущий о проектировании программного 
обеспечения, упоминает это правило. 

... Каждый раз, когда в программе встречается повторяющийся код, он указывает 
на упущенную возможность для абстракции. ...

... Менее тривиальная форма дублирования — цепочки switch/case или i f/el se,  
снова и снова встречающиеся в разных модулях и всегда проверяющие одинаковые 
наборы условий. Вместо них надлежит применять полиморфизм. ...

**G6: Код на неверном уровне абстракции**

В программировании важную роль играют абстракции, отделяющие  
высокоуровневые общие концепции от низкоуровневых подробностей. Иногда эта задача 
решается созданием абстрактных классов, содержащих высокоуровневые  
концепции, и производных классов, в которых хранятся низкоуровневые концепции. 
Действуя подобным образом, необходимо позаботиться о том, чтобы разделение 
было полным. Все низкоуровневые концепции должны быть сосредоточены 
в производных классах, а все высокоуровневые концепции объединяются в  
базовом классе. 
Например, константы, переменные и вспомогательные функции, относящиеся 
только к конкретной реализации, исключаются из базового класса. Базовый класс 
не должен ничего знать о них. 

Правило также относится к исходным файлам, компонентам и модулям.  
Качественное проектирование требует, чтобы концепции разделялись на разных 
уровнях и размещались в разных контейнерах. Иногда такими контейнерами 
являются базовые и производные классы; в других случаях это могут быть  
исходные файлы, модули или компоненты. ...

**G7: Базовые классы, зависящие от производных**

Самая распространенная причина для разбиения концепций на базовые и  
производные классы состоит в том, чтобы концепции базового класса, относящиеся 
к более высокому уровню, были независимы от низкоуровневых концепций 
производных классов. Следовательно, когда в базовом классе встречаются  
упоминания имен производных классов, значит, в проектировании что-то сделано 
не так. В общем случае базовые классы не должны ничего знать о своих  
производных классах. 

Конечно, у этого правила имеются свои исключения. Иногда количество  
производных классов жестко фиксировано, а в базовом классе присутствует код для 
выбора между производными классами. ...

**G8: Слишком много информации**

Хорошо определенные модули обладают компактными интерфейсами, позволяющими сделать много минимальными средствами. Для плохо определенных 
модулей характерны широкие, глубокие интерфейсы, которые заставляют пользователя выполнять много разных операций для решения простых задач. Хорошо 
определенный интерфейс предоставляет относительно небольшое количество 
функций, поэтому степень логической привязки при его использовании относительно невелика. Плохо определенный интерфейс предоставляет множество 
функций, которые необходимо вызывать, поэтому его использование сопряжено 
с высокой степенью логической привязки. 
Хорошие разработчики умеют ограничивать интерфейсы своих классов и модулей. Чем меньше методов содержит класс, тем лучше. Чем меньше переменных 
известно функции, тем лучше. Чем меньше переменных экземпляров содержит 
класс, тем лучше. 
Скрывайте свои данные. Скрывайте вспомогательные функции. Скрывайте константы и временные переменные. Не создавайте классы с большим количеством 
методов или переменных экземпляров. Не создавайте большого количества защищенных переменных и функций в субклассах. Сосредоточьтесь на создании очень компактных, концентрированных интерфейсов. Сокращайте логические 
привязки за счет ограничения информации. 

**G9: Мертвый код**

Мертвым кодом называется код, не выполняемый в ходе работы программы....

... Мертвый код плох тем, что спустя некоторое время он начинает «плохо пахнуть». 
Чем древнее код, тем сильнее и резче запах. Дело в том, что мертвый код не  
обновляется при изменении архитектуры. Он компилируется, но не соответствует 
более новым конвенциям и правилам. Он был написан в то время, когда система 
была другой. Обнаружив мертвый код, сделайте то, что положено делать в таких 
случаях: достойно похороните его. Удалите его из системы. 

**G10: Вертикальное разделение**

Переменные и функции должны определяться вблизи от места их использования. 
Локальные переменные должны объявляться непосредственно перед первым 
использованием и должны обладать небольшой вертикальной областью  
видимости. Объявление локальной переменной не должно отдаляться от места ее 
использования на сотню строк. 
Приватные функции должны определяться сразу же после первого  
использования. Приватные функции принадлежат области видимости всего класса, но 
вертикальное расстояние между вызовами и определениями все равно должно 
быть минимальным. Приватная функция должна обнаруживаться простым  
просмотром кода от места первого использования. 

**G11: Непоследовательность**

Если некая операция выполняется определенным образом, то и все похожие 
операции должны выполняться так же. Это правило возвращает нас к «принципу 
наименьшего удивления». Ответственно подходите к выбору новых схем и обозначений, а если уж выбрали — продолжайте следовать им. 

... Последовательное соблюдение подобных схем и правил существенно упрощает 
чтение и модификацию кода. 

**G12: Балласт**

Какой прок от конструктора по умолчанию, не имеющего реализации? Он только 
попусту загромождает код. Неиспользуемые переменные, невызываемые  
функции, бессодержательные комментарии — все это бесполезный балласт, который 
следует удалить. Поддерживайте чистоту в своих исходных файлах, следите за 
их структурой и не допускайте появления балласта. 

**G13: Искусственные привязки**

То, что не зависит друг от друга, не должно объединяться искусственными  
привязками. Например, обобщенные перечисления не должны содержаться в более 
конкретных классах, потому что в этом случае информация о конкретном  
классе должна быть доступна в любой точке приложения, в которой используется 
перечисление. То же относится и к статическим функциям общего назначения, 
объявляемым в конкретных классах. 

... Главные причины для появления искусственных привязок — лень и небрежность. 

**G14: Функциональная зависть**

Это один из «запахов кода», описанных у Мартина Фаулера [Refactoring]. Для 
методов класса должны быть важны переменные и функции того класса,  которому они принадлежат, а не переменные и функции других классов. Когда метод использует методы доступа другого объекта для манипуляций с его данными, то он завидует области видимости класса этого объекта. Он словно мечтает находиться в другом классе, чтобы иметь прямой доступ к переменным, с которыми он работает. 

**G15: Аргументы-селекторы**

Ничто так не раздражает, как висящий в конце вызова функции аргумент false. ...

... Смысл селектора трудно запомнить, но дело не только в этом — селектор указывает 
на объединение нескольких функций в одну. 

... Конечно, селекторы не обязаны быть логическими величинами. Это могут быть 
элементы перечислений, целые числа или любые другие типы аргументов, в зависимости от которых выбирается поведение функции. В общем случае лучше 
иметь несколько функций, чем передавать функции признак для выбора поведения. 

**G16: Непонятные намерения**

Код должен быть как можно более выразительным. Слишком длинные выражения, венгерская запись, «волшебные числа» — все это скрывает намерения автора. ...

... Не жалейте времени на то, чтобы сделать намерения своего кода максимально прозрачными для читателей.

**G17: Неверное размещение**

Одно из самых важных решений, принимаемых разработчиком, — выбор места 
для размещения кода. ...

... В игру вступает принцип наименьшего удивления. Код следует размещать там, 
где читатель ожидает его увидеть. 

**G18: Неуместные статические методы**

В общем случае отдавайте предпочтение нестатическим методам перед статическими. Если сомневаетесь, сделайте функцию нестатической. Если вы твердо уверены, что функция должна быть статической, удостоверьтесь в том, что от нее не потребуется полиморфное поведение. 

**G19: Используйте пояснительные переменные**

Один из самых эффективных способов улучшения удобочитаемости программы заключается в том, чтобы разбить обработку данных на промежуточные значения, хранящиеся в переменных с содержательными именами. 

... Перестараться в применении пояснительных переменных трудно. Как правило, 
чем больше пояснительных переменных, тем лучше. ...

**G20: Имена функций должны описывать выполняемую операцию**

Если вам приходится обращаться к реализации (или документации), чтобы 
понять, что делает та или иная функция, постарайтесь найти более удачное имя 
или разбейте функциональность на меньшие функции с более понятными  именами. 

**G21: Понимание алгоритма**

Очень много странного кода пишется из-за того, что люди не утруждают себя 
пониманием алгоритмов. Они заставляют программу работать «грубой силой», 
набивая ее командами i f и флагами, вместо того чтобы остановиться и подумать, 
что же в действительности происходит. 

... Прохождения всех тестов недостаточно. Вы должны знать, что ваше решение правильно. 
Один из лучших способов достичь этого знания и понимания — разбить функцию 
на фрагменты настолько чистые и выразительные, что вам станет совершенно 
очевидно, как работает данная функция. 

**G22: Преобразование логических зависимостей в физические**

Если один модуль зависит от другого, зависимость должна быть не только логической, но и физической. Зависимый модуль не должен делать никаких предположений (иначе говоря, создавать логические зависимости) относительно того модуля, от которого он зависит. Вместо этого он должен явно запросить у этого модуля всю необходимую информацию. 

**G23: Используйте полиморфизм вместо if/Else или switch/Case**

... это эвристическое правило напоминает нам о том, что до применения switch следует рассмотреть  возможность применения полиморфизма. 

... правило «ОДНОЙ КОМАНДЫ SWITCH»: для каждого типа выбора программа не должна содержать более одной команды switch. Множественные конструкции switch следует заменять полиморфными объектами. 

**G24: Соблюдайте стандартные конвенции**

Все рабочие группы должны соблюдать единые стандарты кодирования,  
основанные на отраслевых нормах. ...

... Документ с явным описанием этих правил не нужен — сам код служит примером оформления. 
Правила должны соблюдаться всеми участниками группы. Это означает, что 
каждый участник группы должен быть достаточно разумным, чтобы понимать: 
неважно, как именно размещаются фигурные скобки, если только все согласились 
размещать их одинаковым образом. 

**G25: Заменяйте «волшебные числа» именованными константами**

... В общем случае присутствие «сырых» чисел в коде нежелательно. Числа следует 
скрыть в константах с содержательными именами...

... Термин «волшебное число» относится не только к числам. Он распространяется 
на все лексемы, значения которых не являются самодокументирующими. 

**G26: Будьте точны**

Наивно ожидать, что первая запись, возвращаемая по запросу, является 
единственной. Использовать числа с плавающей точкой для представления 
денежных сумм — почти преступление. Отсутствие блокировок и/или  
управления транзакциями только потому, что вы думаете, что одновременное  
обновление маловероятно — в лучшем случае халатность. Объявление переменной 
с типом ArrayList там, где более уместен тип List — чрезмерное ограничение. 
Объявление всех переменных защищенными по умолчанию — недостаточное 
ограничение. 
Принимая решение в своем коде, убедитесь в том, что вы действуете предельно 
точно и аккуратно. Знайте, почему принимается решение, и как вы собираетесь 
поступать с исключениями из правила. Не ленитесь обеспечивать точность своих 
решений. Если вы решили вызвать функцию, которая может вернуть null — проверьте возвращаемое значение. Если вы запрашиваете из базы данных запись, 
которая, по вашему мнению, является единственной — проверьте, не вернул ли 
запрос дополнительные записи. Если вам нужно работать с денежными суммами, 
используйте целые числа и округляйте результат по действующим правилам. 
Если в программе существует возможность одновременного объявления, реализуйте ту или иную разновидность блокировки. Неоднозначности и неточности в коде объясняются либо недопониманием, либо ленью. В любом случае от них следует избавиться. 

**G27: Структура важнее конвенций**

Воплощайте архитектурные решения на уровне структуры кода; она важнее 
стандартов и конвенций. Содержательные имена полезны, но структура,  
заставляющая пользователя соблюдать установленные правила, важнее. Например, 
конструкции switch/case с хорошо выбранными именами элементов  
перечисления уступают базовым классам с абстрактными методами. Ничто не вынуждает пользователя применять одинаковую реализацию switch/case во всех случаях; с другой стороны, базовые классы заставляют его реализовать все абстрактные методы в конкретных классах. 

**G28: Инкапсулируйте условные конструкции**

В булевской логике достаточно трудно разобраться и вне контекста команд i f 
или while. Выделите в программе функции, объясняющие намерения условной 
конструкции. Например, команда 
`if (shouldBeDeleted(timer))` 
выразительнее команды 
`if (timer. hasExpired() && Itimer.isRecurrent()) `

**G29: Избегайте отрицательных условий**

Отрицательные условия немного сложнее для понимания, чем положительные. 
Таким образом, по возможности старайтесь формулировать положительные 
условия. Например, запись 
`if (buffer.shouldCompact()) `
предпочтительнее записи 
`if (!buffer.shouldNotCompact()) `

**G30: Функции должны выполнять одну операцию**

Часто возникает искушение разделить свою функцию на несколько секций для 
выполнения разных операций. Такие функции выполняют несколько операций; 
их следует преобразовать в группу меньших функций, каждая из которых выполняет только одну операцию. 

**G31: Скрытые временные привязки**

Временные привязки часто необходимы, но они не должны скрываться.  
Структура аргументов функций должна быть такой, чтобы последовательность вызова 
была абсолютно очевидной. ...

... Временная привязка реализуется посредством создания «эстафеты». Каждая 
функция выдает результат, необходимый для работы следующей функции, и вызвать эти функции с нарушением порядка сколько-нибудь разумным способом 
уже не удастся. 

Пожалуй, кто-то сочтет, что это увеличивает сложность функций, и это действительно так. Однако дополнительные синтаксические сложности лишь выявляют реальную сложность ситуации, обусловленную необходимостью согласования по времени. 

**G32: Структура кода должна быть обоснована**

Структура кода должна выбираться не произвольно, а по строго определенным 
причинам. Позаботьтесь о том, чтобы эти причины были выражены в структуре 
кода. Если при чтении кода создается впечатление, что его структура выбрана 
произвольно, другим пользователям может показаться, что ее можно изменить. 
Если во всей системе последовательно используется единая структура кода, 
другие пользователи примут ее и сохранят действующие правила. ...

... Открытые классы, не являющиеся вспомогательными по отношению к другому 
классу (то есть используемыми только в его внутренних операциях), не должны 
размещаться внутри других классов. По стандартным правилам такие классы 
объявляются на верхнем уровне своих пакетов. 

**G33: Инкапсулируйте граничные условия**

Отслеживать граничные условия нелегко. Разместите их обработку в одном месте. Не позволяйте им «растекаться» по всему коду. Не допускайте, чтобы в вашей программе кишели многочисленные +1 и -1. 

**G34: Функции должны быть написаны на одном уровне абстракции**

Все команды функции должны быть сформулированы на одном уровне абстракции, который расположен одним уровнем ниже операции, описываемой именем функции. Возможно, это эвристическое правило сложнее всего правильно интерпретировать и соблюдать. Идея достаточно тривиальна, но люди слишком хорошо справляются со смешением разных уровней абстракции. ...

... Разделение уровней абстракции — одна из самых важных и одновременно самых 
сложных в реализации функций рефакторинга. 

... при разбиении функции по уровням абстракции иногда обнаруживаются новые уровни, скрытые прежней структурой. 

**G35: Храните конфигурационные данные на высоких уровнях**

Если в программе имеется константа, определяющая значение по умолчанию 
или параметр конфигурации, и эта константа известна на высоких уровнях  
абстракции, — не прячьте ее в низкоуровневой функции. Передайте ее в аргументе 
низкоуровневой функции, вызываемой из функции высокого уровня. 

... Значения этих констант не принадлежат нижним уровням приложения. 

**G36: Избегайте транзитивных обращений**

В общем случае модуль не должен обладать слишком полной информацией о тех 
компонентах, с которыми он взаимодействует. Точнее, если А взаимодействует 
с В, а В взаимодействует с С, то модули, использующие А, не должны знать о С 
(то есть нежелательны конструкции вида `а.getB().getC().doSomething();`). Иногда 
это называется «законом Деметры». ...

... в дальнейшем вам будет трудно изменить архитектуру системы, вставив между В и С промежуточный компонент Q. 

... Так образуются жесткие, закостеневшие архитектуры. Слишком многие модули располагают слишком подробной информацией о системе. 

... Проблема должна решаться простыми вызовами вида `myCollaborator.doSomething()` 

### Java

**J1: Используйте обобщенные директивы импорта**

Если вы используете два и более класса из пакета, импортируйте весь пакет...

... Список импорта должен быть точной и лаконичной конструкцией, показывающей, с какими пакетами мы собираемся работать. 

Конкретные директивы импорта определяют жесткие зависимости, обобщенные директивы импорта — нет. ...

... обобщенные директивы импорта не создают реальных зависимостей, а следовательно, способствуют смягчению логических привязок между модулями. 

... Обобщенные директивы импорта иногда становятся причиной конфликтов имен 
и неоднозначностей. Два класса с одинаковыми именами, находящиеся в разных 
пакетах, должны импортироваться конкретными директивами... однако ситуация встречается достаточно редко...

**J2: Не наследуйте от констант**

... размещает константы в  интерфейсе, а затем наследует от этого интерфейса для получения доступа к константам....

... Константы скрыты на верхнем уровне иерархии наследования. Брр! Наследование не должно применяться для того, чтобы обойти языковые правила видимости. Используйте статическое импортирование. ...

**J3: Константы против перечислений**

В языке появились перечисления (Java 5) — пользуйтесь ими! Не используйте старый трюк с `public static final int`. Смысл `int` может потеряться; смысл перечислений потеряться не может, потому что они принадлежат указанному перечислению. 

### Имена

**N1: Используйте содержательные имена**

Не торопитесь с выбором имен. Позаботьтесь о том, чтобы имена были содержательными. Помните, что смысл может изменяться в ходе развития программного продукта; почаще переосмысливайте уместность выбранных вами 
имен. 
Не рассматривайте это как дополнительный «фактор комфортности». Имена в программных продуктах на 90% определяют удобочитаемость кода. Не жалейте 
времени на то, чтобы выбрать их осмысленно, и поддерживайте их актуальность. 
Имена слишком важны, чтобы относиться к ним легкомысленно. ...

... Сила хорошо выбранных имен заключается в том, что они дополняют структуру кода описаниями. На основании этих описаний у читателя формируются определенные предположения по поводу того, что делают другие функции модуля. 

**N2: Выбирайте имена на подходящем уровне абстракции**

Не используйте имена, передающие информацию о реализации. Имена должны 
отражать уровень абстракции, на котором работает класс или функция. Сделать 
это непросто — и снова потому, что люди слишком хорошо справляются со смешением разных уровней абстракции.

**N3: По возможности используйте стандартную номенклатуру**

Имена проще понять, если они основаны на существующих конвенциях или стандартных обозначениях. Например, при использовании паттерна ДЕКОРАТОР 
можно включить в имена декорирующих классов слово Decorator. 

... Чем больше вы используете имена, переопределенные специальным смыслом, относящимся к вашему конкретному проекту, тем проще читателю понять, о чем идет речь в вашем коде. 

**N4: Недвусмысленные имена**

Выбирайте имена, которые максимально недвусмысленно передают назначение 
функции или переменной. 

... На первый взгляд имя кажется слишком длинным, но функция вызывается только 
из одной точки модуля, поэтому ее документирующая ценность перевешивает длину

**N5: Используйте длинные имена для длинных областей видимости**

Длина имени должна соответствовать длине его области видимости.  
Переменным с крошечной областью видимости можно присваивать очень короткие 
имена, но у переменных с большей областью видимости имена должны быть 
длинными. 

... Таким образом, чем длиннее область видимости имени, тем более длинным и точным должно быть ее имя. 

**N6: Избегайте кодирования**

Информация о типе или области видимости не должна кодироваться в именах. 
Префиксы вида `m_` или `f` бессмысленны в современных средах. Кроме того, информация о проекте и/или подсистеме (например, префикс `vis_` для подсистемы 
визуализации) также отвлекает читателя и является избыточной. 

**N7: Имена должны описывать побочные эффекты**

Имена должны описывать все, что делает функция, переменная или класс. Не 
скрывайте побочные эффекты за именами. Не используйте простые глаголы для 
описания функции, которая делает что-то помимо этой простой операции. 

### Тесты

**Т1: Нехватка тестов** 
... Тестовый пакет должен тестировать все, что может сломаться. Если в системе остались условия, не проверенные тестами, или вычисления, правильность которых не подтверждена, значит, количество тестов недостаточно.
**Т2: Используйте средства анализа покрытия кода** 
Средства анализа покрытия сообщают о пробелах в вашей стратегии тестирования. Они упрощают поиск модулей, классов и функций с недостаточно полным тестированием. ...
**ТЗ: Не пропускайте тривиальные тесты** 
Тривиальные тесты пишутся легко, а их информативная ценность превышает 
затраты времени на их создание. 

**Т4: Отключенный тест как вопрос** 
Иногда мы не уверены в подробностях поведения системы, потому что неясны сами требования к программе. Вопрос о требованиях можно выразить в виде теста — закомментированного или помеченного аннотацией `@Ignore`. Выбор зависит от того, компилируется или нет код, к которому относится неопределенность. 
**Т5: Тестируйте граничные условия**
Особенно тщательно тестируйте граничные условия. Программисты часто 
правильно реализуют основную часть алгоритма, забывая о граничных ситуациях. 
**Т6: Тщательно тестируйте код рядом с ошибками**
Ошибки часто собираются группами. Если вы обнаружили ошибку в функции, 
особенно тщательно протестируйте эту функцию. Может оказаться, что ошибка 
была не одна. 
**Т7: Закономерности сбоев часто несут полезную информацию**
Иногда анализ закономерностей в сбоях тестовых сценариев помогает выявить 
причины возникших проблем. Это еще один аргумент в пользу максимальной 
полноты тестовых сценариев. Всесторонние наборы тестовых сценариев, упорядоченные логичным образом, выявляют закономерности. ...

**Т8: Закономерности покрытия кода часто несут полезную информацию** 
Анализ того, какой код выполняется или не выполняется в ходе тестирования, 
иногда подсказывает причины возможных сбоев в ходе тестирования. 

**Т9: Тесты должны работать быстро** 
Медленный тест не выполняется за разумное время. Если время поджимает, из 
тестового пакета первыми будут удалены медленные тесты. Сделайте все необходимое для того, чтобы ваши тесты работали быстро. 

### Заключение

... Невозможно написать чистый код, действуя по списку правил. Нельзя стать мастером, изучив набор эвристик. Профессионализм и мастерство формируются на основе ценностей, которыми вы руководствуетесь в обучении. 
