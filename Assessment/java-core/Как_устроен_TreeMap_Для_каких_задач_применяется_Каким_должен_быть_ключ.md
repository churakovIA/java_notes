# Как устроен TreeMap? Для каких задач применяется? Каким должен быть ключ?
---

[JavaDocs: TreeMap](https://docs.oracle.com/javase/8/docs/api/java/util/TreeMap.html)

- TreeMap — реализация, основанная на красно-чёрных деревьях. Является упорядоченной и предоставляет возможность управлять порядком элементов в коллекции при помощи объекта Comparator, либо сохраняет элементы с использованием «natural ordering»
- В отличие от хэш-карты, карта деревьев гарантирует, что ее элементы будут отсортированы в порядке возрастания ключа.
- TreeMap, в отличие от hash map и linked hash map, нигде не использует принцип хеширования, поскольку не использует массив для хранения своих записей.
- Поскольку ключи упорядочены, есть возможность получать подмножества
- Можно вставить ключ null только в пустую TreeMap, иначе будет исключение
- Время доступа и извлечения элементов достаточно мало, что делает класс TreeMap блестящим выбором для хранения больших 
  объемов отсортированной информации, которая должна быть быстро найдена.

Пример: в качестве примера продолжим работу с нашим справочником автором. Не используя кастомных компараторов наши авторы 
будут храниться в алфавитном порядке:

```java

public class Main {

    public static void main(String[] args) {
        Map<String, List<String>> authors = new TreeMap<>();
        authors.put("Достоевский", Arrays.asList("Преступление и наказание", "Идиот"));
        authors.put("Донцова", Arrays.asList("Крутые наследнички", "За всеми зайцами"));
        authors.put("Пушкин", Arrays.asList("Капитанская дочка", "Руслан и Людмила"));
        authors.put("Донцова", Arrays.asList("Белый конь на принце", "Несекретные материалы"));
        authors.put("Роулинг", Arrays.asList("Гарри Поттер и Филосовский Камень", "Гарри Поттер и Тайная Комната"));
        authors.put("Фонвизин", Collections.singletonList("Недоросль"));

        for (Map.Entry<String, List<String>> entry : authors.entrySet()) {
            System.out.println(entry.getKey() + ":" + entry.getValue());
        }
    }
}
```

Результат:
```
Донцова:[Белый конь на принце, Несекретные материалы]
Достоевский:[Преступление и наказание, Идиот]
Пушкин:[Капитанская дочка, Руслан и Людмила]
Роулинг:[Гарри Поттер и Филосовский Камень, Гарри Поттер и Тайная Комната]
Фонвизин:[Недоросль]
```

Так же можно использовать кастомный компаратор и хранить авторов по увеличению длины их фамилии:

```java

public class Main {

    public static void main(String[] args) {
        Map<String, List<String>> authors = new TreeMap<>(Comparator.comparing(String::length));
        authors.put("Достоевский", Arrays.asList("Преступление и наказание", "Идиот"));
        authors.put("Пушкин", Arrays.asList("Капитанская дочка", "Руслан и Людмила"));
        authors.put("Роулинг", Arrays.asList("Гарри Поттер и Филосовский Камень", "Гарри Поттер и Тайная Комната"));
        authors.put("Фонвизин", Collections.singletonList("Недоросль"));

        for (Map.Entry<String, List<String>> entry : authors.entrySet()) {
            System.out.println(entry.getKey() + ":" + entry.getValue());
        }
    }
}

```

Результат:

```
Пушкин:[Капитанская дочка, Руслан и Людмила]
Роулинг:[Гарри Поттер и Филосовский Камень, Гарри Поттер и Тайная Комната]
Фонвизин:[Недоросль]
Достоевский:[Преступление и наказание, Идиот]
```