# Рассказать про устройство HashMap (+ loadFactor, capacity, алгоритмическая сложность).
---

## Перевод javadoc

Реализация интерфейса Map, основанная на хеш-таблице. Поддерживает все операции с map и допускает null в качестве ключа и значения. HashMap похожа на Hashtable, за исключением того, что не синхронизирована и поддерживает null. Этот класс не дает никаких гарантий относительно порядка map; в частности, он не гарантирует, что порядок будет оставаться постоянным с течением времени.  

Эта реализация обеспечивает константное время основных операций (get и put), предполагая, что хэш-функция правильно распределяет элементы по корзинам. Итерация по коллекции требует времени, пропорционального "capacity" экземпляра HashMap (количество корзин) плюс его размер (количество наборов ключ-значение). Таким образом, очень важно не устанавливать слишком высокую начальную capacity (или слишком низкий load factor), если важна производительность итерации.  

Экземпляр HashMap имеет два параметра, влияющих на его производительность: *initial capacity* и *load factor*. Capacity - это количество корзин в хэш-таблице, а initial capacity - это просто capacity на момент создания хэш-таблицы. Load factor - это показатель того, насколько может заполниться хэш-таблица, прежде чем ее емкость будет автоматически увеличена. Когда количество записей в хэш-таблице превышает произведение *load factor* и текущую capacity, хэш-таблица повторно хэшируется (то есть внутренние структуры данных перестраиваются), так что хэш-таблица содержит примерно в два раза больше корзин.  

Как правило, *load factor* по умолчанию (.75) обеспечивает хороший компромисс между затратами времени и памяти. Более высокие значения уменьшают накладные расходы на память, но увеличивают стоимость поиска (отражается в большинстве операций класса HashMap, включая get и put). Ожидаемое количество записей в map и *load factor* следует учитывать при настройке ее initial capacity, чтобы свести к минимуму количество операций повторного хэширования. Операции повторного хэширования никогда не будут выполняться, если initial capacity превышает максимальное количество записей, деленное на *load factor*.  

Если в HashMap надо хранить много записей, то инициализация с достаточно большой capacity позволит делать это более эффективно. Иначе будет снижаться производительность из-за необходимости автоматически пере-хэшировать по мере роста таблицы. Обратите внимание, что использование множества ключей с одним и тем же hashCode() - это верный способ замедлить производительность любой хэш-таблицы.To ameliorate impact, when keys are [`Comparable`](https://docs.oracle.com/javase/8/docs/api/java/lang/Comparable.html), this class may use comparison order among keys to help break ties.

Продолжение следует...

## Как работает HashMap?

У класса Object есть два важных метода hashCode() и equals(Object obj), которые используются для корректной работы HashMap. 
Ключ, по которому кладется значение в HashMap, должен обязательно наследоваться от Object, следовательно, 
примитивные типы не могут быть ключами в HashMap.  
Оба метода и hashCode() и equals(Object obj) вызываются у ключа, после того, как был вызван метод put(key, value).  

- Когда мы помещаем пару ключ/значение в HashMap, то HashMap вычисляет хеш от ключа, вызывая метод hashCode() у ключа.
- Вычисленное значение hashCode берется по модулю от количества bucket'ов в HashMap и помещается по номеру вычисленной позиции в нужный bucket.
- Если в bucket`е по вычисленной позицией уже имеются другие пары ключ/значение, тогда HashMap пробегается по списку объектов и сравнивает ключ с уже лежащими ключами с помощью метода equals(Object obj).

### Какая размерность HashMap по умолчанию?

```java
/**
 * The default initial capacity - MUST be a power of two.
 */
static final int DEFAULT_INITIAL_CAPACITY = 1 << 4; // aka 16
```

### Как и когда происходит увеличение количества корзин в HashMap?

Помимо capacity у HashMap есть еще поле loadFactor, на основании которого, вычисляется предельное количество занятых корзин capacity * loadFactor. По умолчанию loadFactor = 0.75. По достижению предельного значения, число корзин увеличивается в 2 раза и для всех хранимых элементов вычисляется новое «местоположение» с учетом нового числа корзин.

## Ссылки

- [JavaDocs: HashMap](https://docs.oracle.com/javase/8/docs/api/java/util/HashMap.html)
- [Habr: Структуры данных в картинках. HashMap](https://habr.com/ru/post/128017/)