# Методы класса Object?
---

**[Класс Object](https://docs.oracle.com/javase/8/docs/api/java/lang/Object.html)** - суперкласс для всех классов (неявно все классы его наследуют). Ссылка типа *Object* может указывать на объект любого класса или массив, т.к. массив реализован как наследник *Object*.

В классе Object определен набор методов, который наследуется всеми классами:  

- `protected Object clone()` — создает и возвращает копию вызывающего объекта;

- `public boolean equals(Object ob)` — предназначен для использования и переопределения в подклассах с выполнением общих соглашений о сравнении содержимого двух объектов одного и того же типа;

- `public Class getClass()` — возвращает экземпляр типа Class;

- `protected void finalize()` — (deprecated) автоматически вызывается сборщиком мусора (garbage collection) перед уничтожением объекта;

- `public int hashCode()` — вычисляет и возвращает хэш-код объекта (число, в общем случае вычисляемое на основе значений полей объекта);

- `public String toString()` — возвращает представление объекта в виде строки.

- `public final void notify()` - пробуждает один поток, который ожидает на мониторе этого объекта. Если какие-либо потоки ожидают этого объекта, один из них выбирается для пробуждения. Выбор произвольный и зависит от имплементации (jvm?). 

  - Поток становится ожидающим на мониторе объекта, когда вызывает метод `wait`. 
  - Пробуждаясь поток начинает конкурировать  с другими активными потоками, ожидающими монитор этого объекта, обычным образом (т.е. не имеет приоритета).
  - Кидает `IllegalMonitorStateException` - если поток не является владельцем монитора объекта

- `public final void notifyAll()` - пробуждает все потоки, которые ожидают на мониторе этого объекта.

- *wait(), wait(int millis)* - освобождает монитор и переводит вызывающий поток в состояние ожидания до тех пор, пока другой поток не вызовет метод `notify()`/`notifyAll()`. Вызывая метод `wait`, поток должен являться владельцем монитора объекта. Возможны прерывания и ложные пробуждения, поэтому этот метод всегда следует использовать в цикле: 

  ```java
       synchronized (obj) {
           while (<condition does not hold>)
               obj.wait();
           ... // Perform action appropriate to condition
       }
  ```

  - `public final void wait() throws InterruptedException`
  - `public final void wait(long timeout) throws InterruptedException`
  - `public final void wait(long timeout, int nanos) throws InterruptedException`

Необходимо переопределять *boolean equals(Object ob)* и *int hashCode()* если предполагается проверка логической эквивалентности объектов или использование их в коллекциях. Реализация *equals()* в *Object* возвращает истину только в том случае, если обе ссылки указывают на один и тот же объект.

### Метод equals()

В базовой реализации выполняется проверка того, что обе ссылки указывают на один и тот же объект:

```java
public boolean equals(Object obj) { 
    return (this == obj);
}
```

Когда не следует переопределять *equals()*:

- Каждый экземпляр уникален по своей природе (например, Thread)
- Нет необходимости сравнивать объекты (например, java.util.regex.Pattern)
- Суперкласс уже переопределяет equals, и поведение суперкласса подходит для данного класса (например, реализации Set используют equals от AbstractSet)
- Класс является private или package-private и есть уверенность, что equals не будет вызываться. Для уверенности можно в переопределенной реализации кидать исключение.

Когда необходимо переопределять *equals()*:

- Для экземпляров класса применимо понятие “логической эквивалентности“, т.е. фактически разные объекты могут иметь одинаковое содержание.
- Предполагается использовать объекты в коллекциях

При переопределении метода *equals()* должны выполняться соглашения, предусмотренные спецификацией языка Java, а именно:

- *рефлексивность* — объект равен самому себе. Если это нарушить, то после добавления в коллекцию метод contains() сообщит, элемента нет в коллекции.
- *симметричность* — если x.equals(y) возвращает значение true, то и y.equals(x) всегда возвращает значение true;
- *транзитивность* — если метод equals() возвращает значение true при сравнении объектов x и y, а также y и z, то и при сравнении x и z будет возвращено значение true. Связано с принципом подстановки Лисков, который гласит, что любое важное свойство типа должно выполняться и для всех его подтипов, так что любой метод, написанный для типа, должен одинаково хорошо работать и для его подтипов.
- *непротиворечивость* — при многократном вызове метода для двух не подвергшихся изменению за это время объектов возвращаемое значение всегда должно быть одинаковым;
- ненулевая ссылка при сравнении с литералом null всегда возвращает значение false.

При переопределении *equals()* нужно написать unit-тесты для проверки выполнения соглашений - рефлексивность, симметричность, транзитивность.

Рекомендации для хорошего *equals()*:

- Используйте оператор == для проверки того, что аргумент является ссылкой на данный объект
- Используйте оператор instanceof для проверки того, что аргумент имеет корректный тип
- Приводите аргумент к корректному типу
- Для каждого значимого поля класса убедитесь, что значение этого поля в аргументе соответствует полю данного объекта

### Метод hashCode()

Нужно переопределять всегда одновременно с *equals()*. Метод *hashCode()* возвращает хэш-код объекта, вычисление которого управляется следующими соглашениями:

- (:grey_exclamation: главное) все одинаковые по содержанию объекты одного типа должны иметь одинаковые хэш-коды;
- различные по содержанию объекты одного типа могут иметь различные хэш-коды;
- во время работы приложения значение хэш-кода объекта не изменяется, если объект не был изменен.

В идеале хеш-функция должна равномерно распределять множество экземпляров класса по всем значениям *int*.

Правила разработки метода *hashCode()*:

1. Объявите переменную типа *int* с именем *result* и инициализируйте ее хэш-кодом с для первого значащего поля объекта
2. Для остальных полей:
   1. Вычислить хэш-код поля (примитивные - Type.hashCode (f), null - 0, ссылка - hashCode(), массив - Arrays.hashCode())
   2. Объединить с *result*: `result = 31 * result + с;`
3. return result;
4. Написать unit-тесты на то что равные объекты возвращаю одинаковый хэш-код

Умножение на 31 делает результат зависящим от порядка полей и дает гораздо лучшую хеш-функцию. Значение 31 выбрано потому, что оно является нечетным простым числом. Если бы оно было четным и умножение приводило к переполнению, то происходила бы потеря информации, потому что умножение на 2 эквивалентно сдвигу.

Другие способы вычисления hashCode():

- com.google.common.hash.Hashing
- Objects.hash(Object... values)
- Для неизменяемых классов можно вычислять и сохранять в момент создания объекта или через ленивую инициализацию. 

[Habr: Как работает hashCode() по умолчанию?](https://habr.com/ru/company/vk/blog/321306/)

### Метод clone()

Клонирование объекта производится переопределением метода *protected Object clone()* с изменением модификатора доступа на *public* и добавлением реализации маркерного интерфейса *Clonable.* В переопределенном методе следует вызвать базовую версию метода *super.clone()*, которая и выполняет клонирование. Без интерфейса возникает исключение *CloneNotSupportedException.* Открытые методы *clone()* должны опускать конструкцию throws, поскольку методы, не генерирующие проверяемые исключения, более просты в использовании. При использовании этого механизма объект создается без вызова конструктора, на уровне виртуальной машины выполняется побитовое копирование объекта в другую часть памяти. Cледует отказаться от использования *final* полей объектных типов по причине невозможности изменения их значений при реализации глубокого клонирования.

> Почему метод clone() объявлен в классе Object, а не в интерфейсе Cloneable?
>
> Метод clone() объявлен в классе Object с указанием модификатора native, чтобы обеспечить доступ к стандартному механизму поверхностного копирования объектов. Одновременно он объявлен и как protected, чтобы нельзя было вызвать этот метод у не переопределивших его объектов. Непосредственно интерфейс Cloneable является маркерным (не содержит объявлений методов) и нужен только для обозначения самого факта, что данный объект готов к тому, чтобы быть клонированным. Вызов переопределённого метода clone() у не Cloneable объекта вызовет выбрасывание CloneNotSupportedException.

Лучшей альтернативой клонированию являются копирующий конструктор или фабричный метод. В качестве аргумента может выступать интерфейс, например, как это сделано для коллекций. Это позволяет конвертировать объекты одного типа в другой.

Клонирование лучше рассматривать как средство оптимизации, когда оно оправдано. Оно наименее опасно для final классов(почему?). Массивы лучше всего копировать методом clone().

### Метод toString()

Метод toString должен возвращать всю полезную информацию, которая содержится в объекте.  

Предоставляйте программный доступ ко всей информации в значении, возвращаемом методом toString.

Класс Object формирует toString() так:

```java
public String toString() { 
    return getClass().getName() + "@" + Integer.toHexString(hashCode()); 
}
```

 ### Методы `wait`, `notify`, `notifyAll`

Методы `wait`, `notify` и `notifyAll` позволяют нам ожидать в текущем потоке выполнения какого-либо результата из другого потока из состояния ожидания не нагружая процессор ненужными проверками. Эти методы могут вызываться только из синхронизированных блоков кода, иначе они породят исключение `IllegalMonitorStateException`. Метод `wait` переводит текущий поток в состояние ожидания, при этом высвобождая монитор для других потоков. Таким образом, несмотря на то что он вызывается внутри `synchronized`-блока - другой поток в этот момент может захватить монитор для работы с объектом. `wait` работает аналогино `sleep` и может быть прерван либо по таймауту, либо пробужден каким либо событием в приложении. Одним из таких событий является вызов `notify` и `notifyAll`. После пробуждения поток ожидает освобождения монитора, захватаывает его и продолжает работу. С учетом того что пробуждение может быть ложным, либо вызвано сторонними событиями - `wait` следует использовать в цикле `while` с проверкой необходимого нам условия.

Классическим примером использования этого механизма является MailBox которым пользуются два объекта - отправитель и получатель, причем получатель ожидает когда там что-то появится, а отправитель ожидает когда ящик освободится:

```java
public class MailBox {
    private String message;

    private boolean empty = true;

    public synchronized String get() {
        while (empty) {
            try {
                wait();
            } catch (InterruptedException ignored) {}
        }

        empty = true;
        notifyAll();
        return message;
    }

    public synchronized void send(String message) {
        while (!empty) {
            try {
                wait();
            } catch (InterruptedException ignored) {}
        }

        empty = false;
        this.message = message;
        notifyAll();
    }
}
```

