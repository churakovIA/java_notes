# Назовите способы синхронизации потоков
---

#### `synchronized` методы

Ключевое слово `synchronized` в опеределении метода указывает на то, что только один поток может вызывать метод объекта с таким ключевым словом. Т.е. даже если синхронизированных методов несколько штук и различные потоки пытаются вызвать разные методы - в каждый момент времени только один синхронизированный метод объекта может выполняться только одним потоком. Остальне в это время находятся в ожидании пока активный поток не закончит выполнять синхронизированный метод.

Дополнительно, `synchronized`-метод гарантирует что сразу после его выполнения любые другие потоки не будут испытывать проблем с консистеностью памяти - т.е. значения переменных из локальных кешей будут перенесены в общую память.

Конструкторы не могут быть синхронизированны - это не имеет смысла т.к. создание объекта производится в одном и только одном потоке. Попытка сделать конструктор синхронизированным приведет к ошибке компиляции.

`synchronized`-методы являются одним из простейших способов создать thread-safe класс. Это эффективно, но злоупотребление синхронизацией может привести к взаимным блокировкам потоков.

```java
public class SyncIncrementer {
  private int c = 0;
  public synchronized void inc() {
    c++;
  }
  public synchronized int get() {
    return c;
  }
}
```

#### мониторы / внутренние блокировки / `synchronized` блоки 

Каждый объект имеет особое поле предназначение для организации эксклюзивного доступа. Такой механизм называется внутренной блокировкой (*intrinsic lock*) или монитором (*monitor*). Поток, которому необходим монопольный доступ к объекту должен получить (или захватить) монитор объекта и освободить его после того как необходимые изменения в объект будут внесены. Это гарантирует синхронизированный доступ к объекту и позволяет вызвать последовательно несколько изменений или методов.

`synchronized`-метод именно по такой схеме и работает - перед начал выполнения `synchronized`-метода берется монитор объекта после чего выполняется метод, и только после завершения выполнения `synchronized`-метода монитор объекта освобождается.

Статический `synchronized`-метод пользуется монитором объекта типа `Class` - поэтому нужно быть осторожным используя статические синхронизированные методы - единовременно только один поток приложения сможет выполнять этот метод, даже если его вызывают одновременно десятки объектов этого класса.

```java
public void addStudent(String name) {
  synchronized(this) {
    lastStudent = name;
    totalCount++;
  }
}
```

#### `volatile`

Ключевое слово `volatile` используется для объявления переменных и указывает на то что изменения переменной одним поток незамедлительно становятся видны остальным потокам. Т.е. все операции чтения и записи производятся напрямую в общую память, а не в кеш потока. Таким образом это позволяет снизить ошибки консистентности при плотном использовании общих переменных большим количеством потоков.

---

- **Системная синхронизация с использованием `wait()`/`notify()`**. Поток, который ждет выполнения каких-либо условий, вызывает у этого объекта метод `wait()`, предварительно захватив его монитор. На этом его работа приостанавливается. Другой поток может вызвать на этом же самом объекте метод `notify()` (опять же, предварительно захватив монитор объекта), в результате чего, ждущий на объекте поток «просыпается» и продолжает свое выполнение. В обоих случаях монитор надо захватывать в явном виде, через `synchronized`-блок, потому как методы `wait()`/`notify()` не синхронизированы!
- **Системная синхронизация с использованием `join()`**. Метод `join()`, вызванный у экземпляра класса `Thread`, позволяет текущему потоку остановиться до того момента, как поток, связанный с этим экземпляром, закончит работу.
- **Использование классов из пакета `java.util.concurrent`**, который предоставляет набор классов для организации межпоточного взаимодействия. Примеры таких классов - `Lock`, `Semaphore` и пр.. Концепция данного подхода заключается в использовании атомарных операций и переменных.