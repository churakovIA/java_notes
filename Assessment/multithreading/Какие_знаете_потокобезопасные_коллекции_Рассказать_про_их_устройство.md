# Какие знаете потокобезопасные коллекции? Рассказать про их устройство
---

- ArrayBlockingQueue
- ConcurrentHashMap
- ConcurrentLinkedDeque
- ConcurrentLinkedQueue
- ConcurrentSkipListMap
- ConcurrentSkipListSet
- CopyOnWriteArrayList
- CopyOnWriteArraySet
- DelayQueue
- LinkedBlockingDeque
- LinkedBlockingQueue
- LinkedTransferQueue
- PriorityBlockingQueue
- SynchronousQueue

## ConcurrentHashMap

Чтобы надежно обновить значение, следует воспользоваться методом compute (). Этот метод вызывается с ключом и функцией для вычисления нового значения. Данная функция получает ключ и связанное с ним значение, а если таковое отсутствует, то пустое значение null, и далее вычисляет новое значение. Так, в следующей строке кода показано, как правильно обновлять подсчет:  

```
map.compute(word, (k, v) -> v == null ? 1 : v + 1);
```

Метод compute () выполняет атомарную операцию. Это означает, что ни в одном другом потоке исполнения нельзя изменить запись в отображении до тех пор, пока не завершится вычисление в текущем потоке. Имеются варианты computelf Present () и computelf Absent () данного метода, вычисляющие новое значение только в том случае, если уже имеется или еще отсутствует прежнее значение.  

## CopyOnWriteArrayList и CopyOnWriteArraySet

Потокобезопасными являются также коллекции типа CopyOnWriteArrayList и CopyOnWriteArraySet, в которых все модифицирующие методы создают копию массива, положенного в основу коллекции. Такая организация удобна, если количество потоков исполнения, перебирающих коллекцию, заметно превышает количество потоков исполнения, которые изменяют ее. Когда строится итератор, он получает ссылку на текущий массив. Если в дальнейшем этот массив изменяется, итератор по-прежнему имеет прежний массив, но массив коллекции заменяется. Следовательно, прежний итератор имеет согласованное (но потенциально устаревшее) представление, доступное ему без всяких издержек на синхронизацию.

